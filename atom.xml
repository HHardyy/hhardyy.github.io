<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hardy-Zhen</title>
  
  <subtitle>The IT technical communication</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-08T10:12:46.917Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BingZhenHuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象的艺术</title>
    <link href="http://yoursite.com/2018/07/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/07/08/面向对象的艺术/</id>
    <published>2018-07-08T04:58:07.000Z</published>
    <updated>2018-07-08T10:12:46.917Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象的艺术，都是艺术，全是艺术，全是爆炸~</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=415792563&auto=0&height=66"></iframe><br><a id="more"></a></p><blockquote><p>面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能等通过对象来实现，把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是以功能划分问题,<br>把属性和方法写在一起，作为一个相互依存的整体——对象，面向对象有三大特征：封装性、继承性、多态性。就像去一家咖啡店，你只需要和服务员说你要什么样的咖啡，然后只需要等服务员<br>把咖啡拿上来喝掉就可以了，不需要去关注咖啡怎么做，这里服务员就是对象（不是那种对象，是另一种对象），你面向她，拿到你喜欢的咖啡，她也不需要知道你是怎么把咖啡喝完的。顺带<br>提一下面向过程，面向过程就是根据需要分析出解决问题所需要的步骤，顺序执行，其程序结构是按功能划分为若干个基本模块，这些模块形成一个树状结构。各模块之间的关系尽可能简单,<br>在功能上相对独立,每一模块内部均是由顺序、选择和循环三种基本结构组成,其模块化实现的具体方法是使用子程序。程序流程在写程序时就已决定,同样还是刚才的服务员，面向过程就<br>是你和她说要喝什么咖啡，然后浪漫的一起从调料，磨咖啡豆，煮咖啡等等等，然后你张嘴，喝一口，闭嘴，咽下去。。。</p></blockquote><h3 id="面向对象的神器"><a href="#面向对象的神器" class="headerlink" title="面向对象的神器"></a>面向对象的神器</h3><p>之前和一些道友谈论面向对象的过程中得到了一张很厉害的图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/faceobject/1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>系统对象，诸如Array()，Date()这类系统自带的对象<br>一般程序员在讨论说没有对象的时候，总有人说new一个就有了，这里我new一个系统自带的数组对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var arr = new Array();</div></pre></td></tr></table></figure></p><p>对象new出来之后就可以使用它里头的函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.push();  </div><div class="line">arr.sort();</div></pre></td></tr></table></figure></p><p>对象的组成是由肤白+貌美+大长腿。。。错了错了。是由属性和方法构成的</p><h3 id="对象的构成"><a href="#对象的构成" class="headerlink" title="对象的构成"></a>对象的构成</h3><p>诶。。。由于对象是undefined，所以我构造一个对象出来，并且调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var girlFriend=new Girlfriend();    //构造对象</div><div class="line">console.log(<span class="string">"年龄"</span>+girlFriend.age);    //打印对象的年龄</div><div class="line">console.log(<span class="string">"性别"</span>+girlFriend.gender);    //打印对象的性别</div><div class="line">girlFriend.can();     //调用对象的can方法</div><div class="line">girlFriend.canNot();     //调用对象的canNot方法</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/faceobject/2.png" alt="console" title="">                </div>                <div class="image-caption">console</div>            </figure><p>构造的方法很简单，对象的方法我用vue的写法，把Girlfriend.prototype当成vue的methods，因为我觉得相对于它通常的写法略酷一些。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Girlfriend</span></span>()&#123;      //对象的构造函数</div><div class="line">this.age=18;           //对象的属性</div><div class="line">this.gender=<span class="string">"female"</span>;       </div><div class="line">&#125;</div><div class="line">Girlfriend.prototype=&#123;      //对象的方法</div><div class="line"><span class="function"><span class="title">can</span></span>()&#123;</div><div class="line">    console.log(<span class="string">"可以拿来面向"</span>)</div><div class="line">&#125;,</div><div class="line"><span class="function"><span class="title">canNot</span></span>()&#123;</div><div class="line">console.log(<span class="string">"不可以打"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="工厂方式"><a href="#工厂方式" class="headerlink" title="工厂方式"></a>工厂方式</h3><p>知道什么是当当当当吗。。。。。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> createPerson(name)&#123;</div><div class="line">//1.原料</div><div class="line">var obj = new Object();</div><div class="line">//2.加工</div><div class="line">obj.name = name;</div><div class="line">obj.showName = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">console.log( this.name );</div><div class="line">&#125;;</div><div class="line">//3.出场</div><div class="line"><span class="built_in">return</span> obj;</div><div class="line">&#125;</div><div class="line">var p1 = createPerson(<span class="string">'HHardyy'</span>);</div><div class="line">p1.showName();</div><div class="line">var p2 = createPerson(<span class="string">'Hardy'</span>);</div><div class="line">p2.showName();</div></pre></td></tr></table></figure></p><p>但是请记住这里的p1.showName()不等于p2.showName()，即使是传入同一个参数，因为p1.showName()==p2.showName()，它是拿双方的地址来对比的，就像java中一样，但是java中可以用xxx1.equals(xxx2)来对比它们的内容是否相等。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>去改写对象下面公用的方法或者属性,让公用的方法或者属性在内存中存在一份 ( 可以提高性能 )，原型 就相当于写html页面时，CSS中的class，普通方法相当于CSS中的style，例如我在系统的数组对象添加一个求和方法count<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var arr1 = [1,2,3,4];</div><div class="line">var arr2 = [2,2,2,2];</div><div class="line">Array.prototype.count = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">var result = 0;</div><div class="line"><span class="keyword">for</span>(var i=0;i&lt;this.length;i++)&#123;</div><div class="line">result += this[i];</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line">&#125;;</div><div class="line">console.log( arr1.count() );  //10</div><div class="line">console.log( arr2.count() );  //8</div></pre></td></tr></table></figure></p><p>原形下面不止可以是方法，也可以添加属性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.prototype.number=5201314</div></pre></td></tr></table></figure></p><h3 id="工厂方式之原型"><a href="#工厂方式之原型" class="headerlink" title="工厂方式之原型"></a>工厂方式之原型</h3><p>当new去调用一个函数 : 这个时候函数中的this指向创建出来的对象,而且函数的的返回值直接就是this(隐式返回)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Object(name)&#123;</div><div class="line">this.name = name;</div><div class="line">&#125;</div><div class="line">Object.prototype.showName = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">console.log( this.name );</div><div class="line">&#125;;</div><div class="line">var p1 = new Object(<span class="string">'HHardyy'</span>);</div><div class="line">var p2 = new Object(<span class="string">'小方块'</span>);</div><div class="line">alert( p1.showName == p2.showName );  //<span class="literal">true</span></div></pre></td></tr></table></figure></p><p>在JS源码中，系统对象也是基于原型的程序，所以尽量不要去修改或者添加系统对象下面的方法和属性，不然可能导致部分原本js的部分功能改变</p><h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>基本数据类型都有自己对应的包装对象，如String，Number，Boolean ，基本类型会找到对应的包装对象类型，然后包装对象把所有的属性和方法给了基本类型，然后包装对象消失<br>如果在String下面添加number类型的数据，会输出undefined<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var str = <span class="string">'HHardyy'</span>;</div><div class="line">String.prototype.lastValue = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line"><span class="built_in">return</span> this.charAt(this.length-1);</div><div class="line">&#125;;</div><div class="line">alert( str.lastValue() );  //y</div></pre></td></tr></table></figure></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>提到面向对象就肯定会有原型链<em>proto</em>，原型链是实例对象与原型之间的连接，它的最外层是Object.prototype，比如我在最外层添加一个love属性，那么这个属性可以在任何构造出来<br>的对象中调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">HHardyy</span></span>()&#123;</div><div class="line">    this.say=<span class="string">"666"</span>;</div><div class="line">&#125;</div><div class="line">Object.prototype.love = <span class="string">"鸡翅"</span>;</div><div class="line">var h = new HHardyy();</div><div class="line">alert(h.love);   //鸡翅</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/faceobject/3.png" alt="原型链手残图" title="">                </div>                <div class="image-caption">原型链手残图</div>            </figure><p>诶，。。。应该能看懂</p><h3 id="hasOwnProperty-constructor-instanceof-toString"><a href="#hasOwnProperty-constructor-instanceof-toString" class="headerlink" title="hasOwnProperty,constructor,instanceof,toString"></a>hasOwnProperty,constructor,instanceof,toString</h3><p>1、hasOwnProperty:看是不是对象自身下面的属性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log( h.hasOwnProperty(<span class="string">"say"</span>))</div></pre></td></tr></table></figure></p><p>2、in：in运算符和hasOwnProperty不同，只要存在在原型上或者对象上就返回true<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'HHardyy'</span> <span class="keyword">in</span> Object;</div></pre></td></tr></table></figure></p><p>3、constructor:查看对象的构造函数<br>4、instanceof:对象与构造函数在原型链上是否有关系<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(h instanceof Array)</div></pre></td></tr></table></figure></p><p>5、toString():系统对象下面自带的 , 自己写的对象都是通过原型链找object下面的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log( Object.prototype.toString.call(h) == <span class="string">'[object Array]'</span> )</div></pre></td></tr></table></figure></p><p>6、Object.keys:ES5的Object.keys方法可以返回对象上的所有可枚举属性(只有对象上的，从原型上继承的没有)</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的概念：子类不影响父类，子类可以继承父类的一些功能 ( 代码复用 )，继承分成属性继承和方法继承。继承的类型分成拷贝继承，原型继承和类式继承<br>拷贝继承:  通用型的，有new或无new的时候都可以<br>类式继承:  new构造函数<br>原型继承:  无new的对象</p><p>属性的继承 : 调用父类的构造函数 call<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj1 = new Object1(<span class="string">'HHardyy'</span>);</div><div class="line"><span class="keyword">function</span> Object1(name)&#123;   //父类</div><div class="line">this.name = name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> Object2(name,sex)&#123;  //子类</div><div class="line">Object1.call(this,name);</div><div class="line">this.sex = sex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>方法的继承：for in也就是拷贝继承 (jquery也是采用拷贝继承extend),原理就是遍历Object1之后赋给Object2,也可以封装成一个extend方法，在需要用的时候只需要传入2个对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> extend(obj1,obj2)&#123;</div><div class="line"><span class="keyword">for</span>(var attr <span class="keyword">in</span> obj2)&#123;</div><div class="line">obj1[attr] = obj2[attr];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>写好了这个extend方法，可以用来写自定义事件，比如各种弹框、拖拽什么的，先给对象设置默认参数，然后再做个参数传递，然后如果有用户输入参数，则该参数覆盖本身设置的默认参数，达到自定义效果。<br><a href="https://codepen.io/HHardyy/pen/eKqKqV" target="_blank" rel="external">codepen上做的一个小demo</a></p><h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>原型继承的几种方式<br>一、原型链继承<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Object1</span></span>()&#123; this.name=<span class="string">"Object1"</span>; &#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Object2</span></span>()&#123;</div><div class="line">    this.age=<span class="string">"2"</span>; //Object2继承了Object1,通过原型，形成_proto_</div><div class="line">&#125;</div><div class="line">    Object2.prototype=new Object1();</div></pre></td></tr></table></figure></p><p>二、构造函数继承（对象冒充继承<br>为了解决引用共享和超类型无法传参的问题，我们采用一种叫借用构造函数的技术，或者成为对象冒充(伪造对象、经典继承)的技术来解决这两种问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Object1(age)&#123;</div><div class="line">    this.name=[<span class="string">'zhangsan'</span>,<span class="string">'lisi'</span>,<span class="string">'wangwu'</span>]</div><div class="line">    this.age=age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> Object2(age)&#123;</div><div class="line">    Object1.call(this,age); //对象冒充，给超类型传参</div><div class="line">&#125;</div><div class="line">    var o2 = new Object2(20);</div><div class="line">    console.log(o2.age);//20</div><div class="line">    console.log(o2.name);//[<span class="string">'zhangsan'</span>,<span class="string">'lisi'</span>,<span class="string">'wangwu'</span>]</div><div class="line">    o2.name.push(<span class="string">'HHardyy'</span>); //添加的新数据，只给 o2</div><div class="line">    console.log(o2.name)//[<span class="string">'zhangsan'</span>,<span class="string">'lisi'</span>,<span class="string">'wangwu'</span>,<span class="string">'HHardyy'</span>]</div></pre></td></tr></table></figure></p><p>三、组合继承（原型链继承+构造函数继承）<br>原型链+借用构造函数=组合继承。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Object1(age) &#123;</div><div class="line">    this.name = [<span class="string">'zhangsan'</span>,<span class="string">'lisi'</span>,<span class="string">'wangwu'</span>]</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">Object1.prototype.run = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> this.name + this.age;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> Object2(age) &#123;</div><div class="line">    Object1.call(this, age); //对象冒充</div><div class="line">&#125;</div><div class="line">Object2.prototype = new Object1(); //原型链继承</div><div class="line">    var o2 = new Object2(100);</div><div class="line">    console.log(o2.run());</div></pre></td></tr></table></figure></p><p>四、原型式继承<br>借助原型并基于已有的对象创建新对象，同时还不必因此创建自定义类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Object1(o) &#123; //传递一个字面量函数</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125; //创建一个构造函数</div><div class="line">    F.prototype = o; //把字面量函数赋值给构造函数的原型</div><div class="line">    <span class="built_in">return</span> new F(); //最终返回出实例化的构造函数</div><div class="line">&#125;</div><div class="line">var box = &#123; //字面量对象</div><div class="line">    name : <span class="string">'zhangsan'</span>,</div><div class="line">    arr : [<span class="string">'lisi'</span>,<span class="string">'wangwu'</span>,<span class="string">'zhaoliu'</span>]</div><div class="line">&#125;;</div><div class="line">    var box1 = Object1(box); //传递</div><div class="line">    console.log(box1.name);</div><div class="line">    box1.name = <span class="string">'Jack'</span>;</div><div class="line">    console.log(box1.name);</div><div class="line">    console.log(box1.arr);</div><div class="line">    box1.arr.push(<span class="string">'parent'</span>);</div><div class="line">    console.log(box1.arr);</div><div class="line">    var box2 = Object1(box); //传递</div><div class="line">    console.log(box2.name);</div><div class="line">    console.log(box2.arr); //引用类型共享了</div></pre></td></tr></table></figure></p><p>五、寄生组合式继承<br>寄生组合式继承解决了两次调用的问题，组合式继承就会有两次调用的情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> object(o) &#123;</div><div class="line">    <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="built_in">return</span> new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> inheritPrototype(subType, superType) &#123;</div><div class="line">    var prototype = object(superType.prototype);  //创建对象</div><div class="line">    prototype.constructor = subType;              //增强对象</div><div class="line">    subType.prototype = prototype;                //指定对象</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原型式继承其实就是说构造函数和子构造函数，或者说类和子类之间(js中不存在类),唯一的继承传递方式是通过原型，而不是像其他语言直接通过extends(ES6的语法糖出现了extends)<br>，所以需要手写prototype。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Object1 = &#123; name : <span class="string">'HHardyy'</span> &#125;;</div><div class="line">var Object2 = cloneObj(Object1);</div><div class="line">console.log(Object2.name);</div><div class="line"></div><div class="line"><span class="keyword">function</span> cloneObj(obj)&#123;</div><div class="line">var F = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</div><div class="line">F.prototype = obj;</div><div class="line"><span class="built_in">return</span> new F(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h4><p>在js中没有类的概念，所以将js中的构造函数当成类，要做属性和方法继承的时候，要分开继承<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 父类 </div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Object1</span></span>() &#123;  this.name = <span class="string">'HHardyy'</span>; &#125;</div><div class="line">Object1.prototype.showName = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">     alert( this.name ); </div><div class="line">&#125;;</div><div class="line">// 子类</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Object2</span></span>() &#123;&#125;;</div><div class="line">// 将父类创建出来的对象赋值给子类的原型,就是类式继承</div><div class="line">    Object2.prototype = new Object1(); </div><div class="line">    var o2 = new Object2();</div><div class="line">    o2.showName()//HHardyy</div></pre></td></tr></table></figure></p><p>上面这就是一句话继承，这时候把o2.constructor打印出来，发现其实是有问题的，它把Object1给打印了出来<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/faceobject/4.png" alt="Object1" title="">                </div>                <div class="image-caption">Object1</div>            </figure><br>原因是直接把newObject1()赋值给Object2.prototype，它就会把他原先自动生产的还有我们自己添加的原型下面的属性都覆盖掉了，所以把construtor指向给修改了，因此还需要修正con<br>structor指向Object2.prototype.constructor=Object2，其实这么改了以后虽然表面正常了，但还是有问题的，假如Object1的name是个数组[1,2]的话，声明出来的对象.name也不是<br>同一个对象，这时候可以构建一个空对象H()继承Object1的prototype,然后Object2再继承H()的prototype，就可以解决问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象的艺术，都是艺术，全是艺术，全是爆炸~&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=415792563&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="原型" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="hasOwnProperty" scheme="http://yoursite.com/tags/hasOwnProperty/"/>
    
      <category term="constructor" scheme="http://yoursite.com/tags/constructor/"/>
    
      <category term="instanceof" scheme="http://yoursite.com/tags/instanceof/"/>
    
      <category term="toString" scheme="http://yoursite.com/tags/toString/"/>
    
      <category term="原型继承" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    
      <category term="类式继承" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>npm install出现的小问题</title>
    <link href="http://yoursite.com/2018/07/05/npm-install%E5%87%BA%E7%8E%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/05/npm-install出现的小问题/</id>
    <published>2018-07-05T15:00:58.000Z</published>
    <updated>2018-07-05T15:30:18.777Z</updated>
    
    <content type="html"><![CDATA[<p>有个妹子遇到了个小问题，就是项目跑不起来,装不上依赖。so</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=571463950&auto=0&height=66"></iframe><br><a id="more"></a></p><p>咱直接说解决方式，先来看看问题。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/npmInstall/bug.png" alt="npm安装任何依赖包之后这样子" title="">                </div>                <div class="image-caption">npm安装任何依赖包之后这样子</div>            </figure><br>其实这就是说明依赖包需要更新了，这个问题的出现可能是因为你的node和npm的版本撑不起项目的奔跑，<br>这时候只需要升级一下node的版本，window用户建议别升级了直接去官网下载好一点，原因就是我之前踩坑生成的一篇文章<br><a href="https://hhardyy.com/2017/12/20/node-pash%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/" target="_blank" rel="external">文章在这里</a><br>要是懒得看就直接上node官网下载安装吧。<br>安装完node之后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node -v</div></pre></td></tr></table></figure></p><p>如果出现node的版本号，说明node成功，接下来可以更新一下npm了，npm更新比较帅气，但是由于npm自身的更新频率比node高很多，所以可以选择下面的命令更新到最新版。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install npm@latest -g</div></pre></td></tr></table></figure></p><p>也可以选择下面这个命令安装特定安装包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install &lt;package_name&gt;</div></pre></td></tr></table></figure></p><p>node和npm都更新完之后应该没问题了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有个妹子遇到了个小问题，就是项目跑不起来,装不上依赖。so&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=571463950&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>js的时间与时间戳</title>
    <link href="http://yoursite.com/2018/07/04/js%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    <id>http://yoursite.com/2018/07/04/js的时间与时间戳/</id>
    <published>2018-07-04T07:38:46.000Z</published>
    <updated>2018-07-04T10:28:11.307Z</updated>
    
    <content type="html"><![CDATA[<p>玩到一个转换时间戳的问题，突然想知道它能怎么变。。。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=451126390&auto=0&height=66"></iframe><br><a id="more"></a></p><blockquote><p>时间戳能表示一份数据在某个特定时间之前已经存在的、完整的、可验证的数据，通常是一个字符序列就像1530693131572，唯一地标识某一刻的时间。使用数字签名技术产生的数据签名的对象包括原始文件信息、签名参数、签名时间&gt;等信息。时间戳广泛运用在知识产权保护、合同签字、金融账务、电子报价投标、股票交易等方面。</p></blockquote><h3 id="时间转时间戳"><a href="#时间转时间戳" class="headerlink" title="时间转时间戳"></a>时间转时间戳</h3><p>方法有五种，都是通过实例化时间对象Date()来获取当前的时间戳，为了防止测试结果不一致，这里实例化一个时间对象data来进行五种方法测试；<br>第一种：通过原型方法直接获得当前时间的毫秒值，比较准确<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var t1=data.getTime();</div><div class="line">console.log(<span class="string">"第一种方法时间戳"</span>+t1)</div></pre></td></tr></table></figure></p><p>第二种：通过valueOf()函数返回指定对象的原始值获得准确的时间戳值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var t2=data.valueOf();</div><div class="line">console.log(<span class="string">"第二种方法时间戳"</span>+t2)</div></pre></td></tr></table></figure></p><p>第三种：将时间转化为一个number类型的时间戳值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var t3=Number(data);</div><div class="line">console.log(<span class="string">"第三种方法时间戳"</span>+t3)</div></pre></td></tr></table></figure></p><p>第四种:貌似多年前学ASP.NET的时候用到过类似的，不过那个是DataTime.Now;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var t4=Date.now();</div><div class="line">console.log(<span class="string">"第四种方法时间戳"</span>+t4)</div></pre></td></tr></table></figure></p><p>第五种：不太厉害，毫秒级别的数值被转化成000<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var t5=Date.parse(data);</div><div class="line">console.log(<span class="string">"第五种方法时间戳"</span>+t5)</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Data/1.png" alt="时间艺术" title="">                </div>                <div class="image-caption">时间艺术</div>            </figure><h3 id="时间戳转时间"><a href="#时间戳转时间" class="headerlink" title="时间戳转时间"></a>时间戳转时间</h3><p>直接用时间对象Date来对上面得到的时间戳1530693131572进行转化<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var T=new Date(1530693131572)</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Data/2.png" alt="转化的艺术" title="">                </div>                <div class="image-caption">转化的艺术</div>            </figure><p>对这个格式不太满意的话，可以再利用toLocaleDateString()方法返回该日期对象，再正则匹配将/替换成-，再将对象的时间部分转换为字符串，到这一步之后还剩yyyy-MM-dd hh:mm:ss GMT+0800(中国标准时间)，这时候再用substr方法取从0到8的字符打印出来就是yyyy-MM-dd hh:mm:ss的时间格式了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T.toLocaleDateString().replace(/\//g, <span class="string">"-"</span>) + <span class="string">" "</span> + T.toTimeString().substr(0, 8);</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Data/3.png" alt="正则的艺术" title="">                </div>                <div class="image-caption">正则的艺术</div>            </figure><p>toLocaleDateString在不同的浏览器显示方法是不一样的，需要注意一下，火狐下面显示的日期格式是yyyy-MM-dd，IE11是yyyy-MM-dd，谷歌版本低于58的时候yyyy/MM/dd，版本大于等于58的时候是yyyy-MM-dd，所以如果上面出现的效果不对或者报错，是因为toLocaleDateString()因浏览器而异。</p><p>解决方法：<br>分别获取时间的年月日然后拼接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">getDate</span></span>()&#123;</div><div class="line">var data=new Date();</div><div class="line"><span class="built_in">let</span> year=data.getFullYear();</div><div class="line"><span class="built_in">let</span> month=(<span class="string">"0"</span>+(data.getMonth()+1)).slice(-2);</div><div class="line"><span class="built_in">let</span> day=(<span class="string">"0"</span>+data.getDate()).slice(-2);</div><div class="line"><span class="built_in">return</span> year + <span class="string">"-"</span> + month + <span class="string">"-"</span> + day + <span class="string">" "</span> + data.toTimeString().substr(0, 8);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>正好今天百度2018AI开发者大会，share一下我早上截屏到的几张美照<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Data/du2.png" alt="新时器--这是表白的时候定的玫瑰花快递刚好送到" title="">                </div>                <div class="image-caption">新时器--这是表白的时候定的玫瑰花快递刚好送到</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Data/du1.png" alt="见证历史的时刻--Apollo3.0面向量产，更加开放" title="">                </div>                <div class="image-caption">见证历史的时刻--Apollo3.0面向量产，更加开放</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Data/kunlun.png" alt="昆仑--百度自研的中国第一款云端全功能AI芯片" title="">                </div>                <div class="image-caption">昆仑--百度自研的中国第一款云端全功能AI芯片</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;玩到一个转换时间戳的问题，突然想知道它能怎么变。。。&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=451126390&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="时间" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="时间戳" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    
      <category term="toLocaleDateString" scheme="http://yoursite.com/tags/toLocaleDateString/"/>
    
  </entry>
  
  <entry>
    <title>Linux艺术</title>
    <link href="http://yoursite.com/2018/07/03/Linux%E8%89%BA%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/07/03/Linux艺术/</id>
    <published>2018-07-03T05:39:54.000Z</published>
    <updated>2018-07-03T14:59:56.314Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是一套基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU,可以免费使用和自由传播的类Unix操作系统。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29539085&auto=0&height=66"></iframe><br><a id="more"></a></p><blockquote><p>linux能运行主要的UNIX工具软件、应用程序和网络协议，支持32位和64位硬件。继承了Unix以网络为核心的设计思想。Linux存在着许多不同的Linux版本，但都使用Linux内核。可安装在各种计算机硬件&gt;设备中，严格来讲，Linux这个词本身只表示Linux内核，只是大家习惯了用Linux来形容整个基于Linux内核，并且使用GNU工程各种工具和数据库的操作系统。</p></blockquote><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>Linux的文件系统目录结构采用分层结构<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/linux/1.png" alt="文件系统的分层结构" title="">                </div>                <div class="image-caption">文件系统的分层结构</div>            </figure><br>在linux中，可执行的二进制文件可以不要扩展名</p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>用户分成3类<br>用户（user），组（group），其他用户（other）,所有用户(all)=u,g,o,a<br>权限也分成3类<br>读（read）,写（write）,执行权限（excute）=r，w，x,三种权限既可以单独使用也可以组合使用<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/linux/2.png" alt="文件系统的分层结构" title="">                </div>                <div class="image-caption">文件系统的分层结构</div>            </figure><br>比如我给文件hhardyy.txt的属主增加执行权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod  u+x  hhardyy.txt</div></pre></td></tr></table></figure></p><p>将文件hhardyy.txt的属组去掉写权限，同时将其他用户设置为只有执行权限，而文件属主的权限不变。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod  g-w,o=x  hhardyy.txt</div></pre></td></tr></table></figure></p><p>chmod的数字使用方式也是很方便的，关键是数制转换的问题。这种方式是先将每个权限位化成二进制数，其中如果某权限位是“-”则用0来表示，否则用1来表示；接着，将这9列权限分为三组（每三位一组），再将每组化成一个八进制数。例如，某文件有如下权限rwxrw-r–，则转换为二进制数为111110100，再化为八进制数则为764；反之，当看到八进制数764时也应该很快转化为相应权限。<br>例如，将文件hhardyy.txt的权限设置为：属主拥有全部权限,属组拥有读写权限,其他用户拥有执行权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod  764  hhardyy.txt</div></pre></td></tr></table></figure></p><h3 id="shell的爆炸艺术"><a href="#shell的爆炸艺术" class="headerlink" title="shell的爆炸艺术"></a>shell的爆炸艺术</h3><p>Shell是指“提供使用者使用界面”的软件（命令解析器），它类似于DOS下的command.com和后来的cmd.exe，以及node的bash。<br>用linux带的编辑编一个shell脚本输出IT界最强的大佬Hello,world:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">命令</div><div class="line">vi hello.sh</div><div class="line"></div><div class="line">内容</div><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">echo</span> “Hello,world!”</div></pre></td></tr></table></figure></p><p>shell脚本是按行解释的，每个脚本的第一行总是以#!/bin/sh开头 。<br>执行shell脚本的几种方式有：<br>1.sh hhardyy.sh<br>2../hhardyy.sh<br>3.source hhardyy.sh    or     .  hhardyy.sh<br>4.直接执行，就是给脚本hhardyy.sh增加执行权chmod  a+x  hhardyy.sh<br>也可以把命令写到shell脚本执行<br>比如我要挂载光驱<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">命令</div><div class="line">vi mount.sh</div><div class="line"></div><div class="line">内容</div><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">mkdir -p mnt/cdrom</div><div class="line">mount /dev/cdrom ~/mnt/cdrom</div></pre></td></tr></table></figure></p><h3 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h3><p>iptables是Linux上常用的防火墙软件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install iptables    //安装</div></pre></td></tr></table></figure></p><h4 id="清除已有iptables规则"><a href="#清除已有iptables规则" class="headerlink" title="清除已有iptables规则"></a>清除已有iptables规则</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iptables -F</div><div class="line">iptables -X</div><div class="line">iptables -Z</div></pre></td></tr></table></figure><h4 id="开放指定的端口"><a href="#开放指定的端口" class="headerlink" title="开放指定的端口"></a>开放指定的端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#允许本地回环接口(即运行本机访问本机)</span></div><div class="line">iptables -A INPUT -i lo -j ACCEPT</div><div class="line"><span class="comment"># 允许已建立的或相关连的通行</span></div><div class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</div><div class="line"><span class="comment">#允许所有本机向外的访问</span></div><div class="line">iptables -A OUTPUT -j ACCEPT</div><div class="line"><span class="comment"># 允许访问22端口</span></div><div class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</div><div class="line"><span class="comment">#允许访问80端口</span></div><div class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</div><div class="line"><span class="comment">#允许访问443端口</span></div><div class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</div><div class="line"><span class="comment">#允许FTP服务的21和20端口</span></div><div class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT</div><div class="line">iptables -A INPUT -p tcp --dport 20 -j ACCEPT</div><div class="line"><span class="comment">#如果有其他端口的话，规则也类似，稍微修改上述语句就行</span></div><div class="line"><span class="comment">#允许ping</span></div><div class="line">iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</div><div class="line"><span class="comment">#禁止其他未允许的规则访问</span></div><div class="line">iptables -A INPUT -j REJECT  <span class="comment">#（注意：如果22端口未加入允许规则，SSH链接会直接断开。）</span></div><div class="line">iptables -A FORWARD -j REJECT</div></pre></td></tr></table></figure><h4 id="屏蔽IP"><a href="#屏蔽IP" class="headerlink" title="屏蔽IP"></a>屏蔽IP</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#如果只是想屏蔽IP的话“3、开放指定的端口”可以直接跳过。</span></div><div class="line"><span class="comment">#屏蔽单个IP的命令是</span></div><div class="line">iptables -I INPUT -s 123.45.6.7 -j DROP</div><div class="line"><span class="comment">#封整个段即从123.0.0.1到123.255.255.254的命令</span></div><div class="line">iptables -I INPUT -s 123.0.0.0/8 -j DROP</div><div class="line"><span class="comment">#封IP段即从123.45.0.1到123.45.255.254的命令</span></div><div class="line">iptables -I INPUT -s 124.45.0.0/16 -j DROP</div><div class="line"><span class="comment">#封IP段即从123.45.6.1到123.45.6.254的命令是</span></div><div class="line">iptables -I INPUT -s 123.45.6.0/24 -j DROP</div></pre></td></tr></table></figure><h4 id="查看已添加的iptables规则"><a href="#查看已添加的iptables规则" class="headerlink" title="查看已添加的iptables规则"></a>查看已添加的iptables规则</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iptables -L -n</div><div class="line">v：显示详细信息，包括每条规则的匹配包数量和匹配字节数</div><div class="line">x：在 v 的基础上，禁止自动单位换算（K、M） vps侦探</div><div class="line">n：只显示IP地址和端口号，不将ip解析为域名</div><div class="line">iptables -I INPUT -s 123.45.6.0/24 -j DROP</div></pre></td></tr></table></figure><h4 id="删除已添加的iptables规则"><a href="#删除已添加的iptables规则" class="headerlink" title="删除已添加的iptables规则"></a>删除已添加的iptables规则</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">将所有iptables以序号标记显示，执行：</div><div class="line">iptables -L -n --line-numbers</div><div class="line">比如要删除INPUT里序号为8的规则，执行：</div><div class="line">iptables -D INPUT 8</div></pre></td></tr></table></figure><p>iptables的开机启动及规则保存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">CentOS上可能会存在安装好iptables后，iptables并不开机自启动，可以执行一下：</div><div class="line">chkconfig --level 345 iptables on</div><div class="line">将其加入开机启动。</div><div class="line">CentOS上可以执行：service iptables save保存规则。</div><div class="line">另外更需要注意的是Debian/Ubuntu上iptables是不会保存规则的。</div><div class="line">需要按如下步骤进行，让网卡关闭是保存iptables规则，启动时加载iptables规则：</div><div class="line">创建/etc/network/<span class="keyword">if</span>-post-down.d/iptables 文件，添加如下内容：</div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">iptables-save &gt; /etc/iptables.rules</div><div class="line">执行：chmod +x /etc/network/<span class="keyword">if</span>-post-down.d/iptables 添加执行权限。</div><div class="line">创建/etc/network/<span class="keyword">if</span>-pre-up.d/iptables 文件，添加如下内容：</div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">iptables-restore &lt; /etc/iptables.rules</div><div class="line">执行：chmod +x /etc/network/<span class="keyword">if</span>-pre-up.d/iptables 添加执行权限。</div></pre></td></tr></table></figure></p><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。<br>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。<br>配置本地yum源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1、挂载DVD光盘</div><div class="line">mount /dev/cdrom /mnt/cdrom   //mnt/cdrom是我自定义的目录，挂载光驱成功之后，成功会在cdrom下面出现一个Packages文件包</div><div class="line">2、在目录/etc/yum.repos.d/创建文件文件名(任意名).repo </div><div class="line">3、配置本地yum源</div><div class="line"><span class="built_in">cd</span> /etc/yum.repos.d/   <span class="comment">#进入yum配置目录 </span></div><div class="line">touch  centos.repo   <span class="comment">#建立yum配置文件 </span></div><div class="line">vim  centos.repo   <span class="comment">#编辑配置文件，添加以下内容 </span></div><div class="line">[centos-yum]</div><div class="line">name=centos   <span class="comment">#自定义名称 </span></div><div class="line">baseurl=file:///mnt<span class="comment">#本地光盘挂载路径 </span></div><div class="line">enabled=1   <span class="comment">#启用yum源，0为不启用，1为启用 </span></div><div class="line">gpgcheck=0  <span class="comment">#检查GPG-KEY，0为不检查，1为检查 </span></div><div class="line">:wq! <span class="comment">#保存退出 </span></div><div class="line"></div><div class="line">4、测试使用yum命令自动安装软件</div><div class="line">yum clean all   <span class="comment">#清除yum缓存 </span></div><div class="line">yum makecache  <span class="comment">#缓存本地yum源中的软件包信息</span></div></pre></td></tr></table></figure></p><p>这里提示一下，假如要用yum安装dhcp的时候提示失败，很可能是因为安装源是网络源，而不是挂载的本地源，这时候要把默认的网络源禁掉就可以了，所谓禁掉就是把网络源的配置文件改个名字，它找不到了本地源就生效了<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/linux/3.png" alt="把网络源文件CentOS-Base.repo改名成CentOS-Base.repo.bak" title="">                </div>                <div class="image-caption">把网络源文件CentOS-Base.repo改名成CentOS-Base.repo.bak</div>            </figure></p><h4 id="yum-选项-参数"><a href="#yum-选项-参数" class="headerlink" title="yum(选项)(参数)"></a>yum(选项)(参数)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-h：显示帮助信息； </div><div class="line">-y：对所有的提问都回答“yes”； </div><div class="line">-c：指定配置文件；</div><div class="line">-q：安静模式；</div><div class="line">-v：详细模式；</div><div class="line">-d：设置调试等级（0-10）； </div><div class="line">-e：设置错误等级（0-10）；</div><div class="line">-R：设置yum处理一个命令的最大等待时间；</div><div class="line">-C：完全从缓存中运行，而不去下载或者更新任何头文件。</div></pre></td></tr></table></figure><h4 id="yum参数"><a href="#yum参数" class="headerlink" title="yum参数"></a>yum参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">install：安装rpm软件包； </div><div class="line">update：更新rpm软件包；</div><div class="line">check-update：检查是否有可用的更新rpm软件包；</div><div class="line">remove：删除指定的rpm软件包；</div><div class="line">list：显示软件包的信息；</div><div class="line">search：检查软件包的信息；</div><div class="line">info：显示指定的rpm软件包的描述信息和概要信息；</div><div class="line">clean：清理yum过期的缓存；</div><div class="line">shell：进入yum的shell提示符； </div><div class="line">resolvedep：显示rpm软件包的依赖关系； </div><div class="line">localinstall：安装本地的rpm软件包； </div><div class="line">localupdate：显示本地rpm软件包进行更新； </div><div class="line">deplist：显示rpm软件包的所有依赖关系。</div></pre></td></tr></table></figure><h4 id="部分常用的yum命令"><a href="#部分常用的yum命令" class="headerlink" title="部分常用的yum命令"></a>部分常用的yum命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">自动搜索最快镜像插件：yum install yum-fastestmirror </div><div class="line">安装yum图形窗口插件：yum install yumex </div><div class="line">查看可能批量安装的列表：yum grouplist </div><div class="line">安装 yum install </div><div class="line">全部安装 yum install package1 </div><div class="line">安装指定的安装包package1 yum groupinsall group1</div><div class="line">安装程序组group1 更新和升级 yum update </div><div class="line">全部更新 yum update package1 </div><div class="line">更新指定程序包package1 yum check-update </div><div class="line">检查可更新的程序 yum upgrade package1 </div><div class="line">升级指定程序包package1 yum groupupdate group1 </div><div class="line">升级程序组group1 查找和显示 yum info package1 </div><div class="line">显示安装包信息package1 yum list </div><div class="line">显示所有已经安装和可以安装的程序包 yum list package1 </div><div class="line">显示指定程序包安装情况package1 yum groupinfo group1</div><div class="line">显示程序组group1信息yum search string 根据关键字string查找安装包 删除程序 yum remove | erase package1 </div><div class="line">删除程序包package1 yum groupremove group1</div><div class="line">删除程序组group1 yum deplist package1 </div><div class="line">查看程序package1依赖情况 清除缓存 yum clean packages</div><div class="line">清除缓存目录下的软件包 yum clean headers </div><div class="line">清除缓存目录下的 headers yum clean oldheaders </div><div class="line">清除缓存目录下旧的 headers</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux是一套基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU,可以免费使用和自由传播的类Unix操作系统。&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=29539085&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="文件系统" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="一丢丢shell" scheme="http://yoursite.com/tags/%E4%B8%80%E4%B8%A2%E4%B8%A2shell/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
      <category term="yum" scheme="http://yoursite.com/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之XSS、SQL注入</title>
    <link href="http://yoursite.com/2018/07/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E3%80%81SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2018/07/01/Web安全之XSS、SQL注入/</id>
    <published>2018-07-01T08:16:36.000Z</published>
    <updated>2018-07-01T17:24:03.360Z</updated>
    
    <content type="html"><![CDATA[<p>XSS跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=559926957&auto=0&height=66"></iframe><br><a id="more"></a></p><h3 id="XSS的攻击方法"><a href="#XSS的攻击方法" class="headerlink" title="XSS的攻击方法"></a>XSS的攻击方法</h3><p>XSS主要分为反射型和存储型两种，它与SQL注入攻击类似，SQL注入攻击中以SQL语句作为用户输入，从而达到的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。</p><h3 id="1、反射型"><a href="#1、反射型" class="headerlink" title="1、反射型"></a>1、反射型</h3><p> 发出请求时，xss代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，xss代码随响应内容一起传回给浏览器，最后浏览器解析执行xss代码。这个过程像一次反射。<br>（1）xss代码出现在url中，反射型代码特征=明文<br>（2）服务器端解析后响应，例如在serch中，参数serch传入，同value部分被一起传回。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>用express做了一个轻量级服务架构实例模拟xss的反射型攻击，装上依赖之后就可以跑起来。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websave/express2.JPG" alt="express艺术" title="">                </div>                <div class="image-caption">express艺术</div>            </figure><br>路由下的接口通过query获取用户在浏览器中输入的serch的内容</p><h4 id="路由router-index-js"><a href="#路由router-index-js" class="headerlink" title="路由router/index.js"></a>路由router/index.js</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var express = require(<span class="string">'express'</span>);</div><div class="line">var router = express.Router();</div><div class="line">/* GET home page. */</div><div class="line">router.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">  res.render(<span class="string">'index'</span>, &#123; title: <span class="string">'Express'</span>,xss:req.query.xss&#125;);</div><div class="line">&#125;);</div><div class="line">module.exports = router;</div></pre></td></tr></table></figure><h4 id="视图views-index-js"><a href="#视图views-index-js" class="headerlink" title="视图views/index.js"></a>视图views/index.js</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=<span class="string">""</span>&gt;</div><div class="line">    &lt;%- xss %&gt;   //将那个接口获取的字段解析显示</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websave/express3.JPG" alt="用xss拼接上12之后" title="">                </div>                <div class="image-caption">用xss拼接上12之后</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websave/express4.JPG" alt="xss" title="">                </div>                <div class="image-caption">xss</div>            </figure><p>拼接上了恶意代码，被浏览器拦截，这里关掉浏览器的拦截，再重启服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">  res.set(<span class="string">'X-XSS-Protection'</span>,0);</div><div class="line">  res.render(<span class="string">'index'</span>, &#123; title: <span class="string">'Express'</span>,xss:req.query.xss&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>拼接上的html和js成功被执行<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websave/express5.JPG" alt="xss" title="">                </div>                <div class="image-caption">xss</div>            </figure><br>假如拼接上Iframe，植入广告，这里举例植入百度（我的百度皮肤是自己设置过的，所以可能不一样）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websave/express6.JPG" alt="百度成功被嵌入到了页面上" title="">                </div>                <div class="image-caption">百度成功被嵌入到了页面上</div>            </figure></p><h3 id="2、存储型"><a href="#2、存储型" class="headerlink" title="2、存储型"></a>2、存储型</h3><p> 存储型xss和反射型xss的差别仅在于，提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交xss代码，和反射型的差别仅在于提交的代码的存储位置。<br> 存储型的代码不是query数据了，而是sql语句,两者的视图渲染流程一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">  res.set(<span class="string">'X-XSS-Protection'</span>,0);</div><div class="line">  res.render(<span class="string">'index'</span>, &#123; title: <span class="string">'Express'</span>,xss:sql()&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="反射型与存储型的区别"><a href="#反射型与存储型的区别" class="headerlink" title="反射型与存储型的区别"></a>反射型与存储型的区别</h3><p>代码不同：<br>1、反射型，通过req.query.xss获取用户输入进行的脚本攻击<br>2、存储型，xss：sql()，通过读缓存或者数据库进行的</p><h3 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h3><h4 id="1、编码"><a href="#1、编码" class="headerlink" title="1、编码"></a>1、编码</h4><p>   对用户输入的数据进行Html Entity编码<br>   <img src="/images/websave/HTML_UTITY.jpg" alt="Html Entity"></p><h4 id="2、过滤"><a href="#2、过滤" class="headerlink" title="2、过滤"></a>2、过滤</h4><p>  （1）移除用户上传的dom属性，如onerror等<br>  （2）移除用户上传的Style节点、Script节点、Iframe节点等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">假如style&#123;body:display:none !important&#125;</div><div class="line">假如Script引入一个破坏的js，js对页面有100%操作权限，非同意的</div><div class="line">假如iframe植入广告，假如植入之后诱导用户鼠标滑过某个地方就会触发某些事件处理函数</div></pre></td></tr></table></figure></p><h4 id="3、校正"><a href="#3、校正" class="headerlink" title="3、校正"></a>3、校正</h4><p>  (1)避免直接对HTML Entity解码（如果直接进行解码，过滤就没意义了）<br> （2）使用DOM Parse转换，转正不配对的DOM标签<br>  DOM Parse=把整个字符串或者文本转成dom结构，执行过滤，然后匹配不合适标签</p><p>页面中反转译输入内容，前端过滤不安全的标签以及不安全的属性，<br>不安全的标签有：script，style，link，iframe，frame，img等，只要是自动加载的，改变页面样式，能够执行js的标签<br>不安全的属性：onerror，onclick等，只要是能够执行js的属性</p><p><a href="https://github.com/HHardyy/XSS_demo" target="_blank" rel="external">express框架实现的demo地址</a></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>攻击者通过在应用程序中预先定义好的查询语句中加上额外的SQL语句元素，欺骗数据库服务器执行非授权的任意查询。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>通过畸形输入巧妙构造符合攻击要求的特殊SQL语句让数据库执行。<br>比如 你的检测语句是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select  * from  user <span class="built_in">where</span> name=<span class="string">'变量1'</span> and password=<span class="string">'变量2'</span></div></pre></td></tr></table></figure></p><p>如果能找到记录则判定登陆成功。<br>那么对方如果在填写用户名和密码的时候写密码’1’ or ‘1’=’1’,把这个替换到最后形成的sql语句就变成了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select  * from  user <span class="built_in">where</span> name=<span class="string">'1'</span> or <span class="string">'1'</span>=<span class="string">'1'</span> and password=<span class="string">'1'</span> or <span class="string">'1'</span>=<span class="string">'1'</span></div></pre></td></tr></table></figure></p><p>由于1=1是恒等的。也就会把所有记录给查出来。这样就可以达到不知道密码或者是用户名的情况下完成登陆。</p><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>对输入缺乏检查过滤。</p><h4 id="危害性"><a href="#危害性" class="headerlink" title="危害性"></a>危害性</h4><p>通过合法途径执行非法语句，使安全措施失效，隐蔽性强。</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>做好应用系统输入的检查、尽量不要用系统管理员用户连接数据库、尽量不要使用扩展存储过程</p><h4 id="So"><a href="#So" class="headerlink" title="So?"></a>So?</h4><p>1、SQL注入将恶意代码放置在SQL中执行<br>2、跨站脚本将恶意代码嵌入到html中执行<br>3、Cookie注入将将恶意代码放置到Cookie中欺骗服务器，或实现SQL和跨站脚本注入。</p><p><span style="color: red">对输入内容进行检查是防御注入攻击的有效方法,以尽可能低的权限运行服务可有效降低服务出现安全问题可能带来的风害。</span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XSS跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=559926957&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="XSS" scheme="http://yoursite.com/tags/XSS/"/>
    
      <category term="Sql注入" scheme="http://yoursite.com/tags/Sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Vue全家桶</title>
    <link href="http://yoursite.com/2018/06/10/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <id>http://yoursite.com/2018/06/10/Vue全家桶/</id>
    <published>2018-06-10T08:02:10.000Z</published>
    <updated>2018-06-10T11:22:55.527Z</updated>
    
    <content type="html"><![CDATA[<p>vue全家桶也就是1.脚手架、2.路由、3.状态管理、4.请求工具~。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=559931973&auto=0&height=66"></iframe><br><a id="more"></a><br>Vue是一套用于构建用户界面的MVVM渐进式框架。与其它大型框架不同的是，Vue的核心库只关注视图层，数据驱动，目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件，不再是传统的操作dom进行界面控制，当然也不是说完全不操作dom，必要的时候还是可以操作的，同时组件化的方式让项目维护起来特别的爽，Vue便于与第三方库或既有项目整合，当与单文件组件和Vue生态系统支持的库结合使用时，Vue也完全能够为复杂的单页应用程序提供驱动。</p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>也叫vue脚手架工具，脚手架是为了保证各施工过程顺利进行而搭设的工作平台，顾名思义在vue中是用于快速构建vue项目的工具，构建的大致步骤如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装vue脚手架</span></div><div class="line">npm install -g vue-cli</div><div class="line"></div><div class="line"><span class="comment"># 安装webpack模板，testproject=项目名</span></div><div class="line">vue init webpack testproject</div><div class="line"></div><div class="line"><span class="comment"># 安装项目需要的依赖包 </span></div><div class="line">npm install</div><div class="line"></div><div class="line"><span class="comment"># 运行项目</span></div><div class="line">npm run dev</div></pre></td></tr></table></figure></p><p>这样就可以跑出一个初始化的vue项目，拖到sublime就可以看到各目录文件<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vue-family/vue-cli.png" alt="“构建的项目目录”" title="">                </div>                <div class="image-caption">“构建的项目目录”</div>            </figure><br>这个目录的意思就是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">1、build //项目构建(webpack)相关代码</div><div class="line"><span class="comment"># build.js=生产环境构建代码</span></div><div class="line"><span class="comment"># check-versions.js=检查node&amp;npm等版本</span></div><div class="line"><span class="comment"># utils.js=构建配置公用工具</span></div><div class="line"><span class="comment"># vue-loader.conf.js=vue加载器</span></div><div class="line"><span class="comment"># webpack.base.conf.js=webpack基础环境配置</span></div><div class="line"><span class="comment"># webpack.dev.conf.js=webpack开发环境配置包括构建本地服务器</span></div><div class="line"><span class="comment"># webpack.prod.conf.js=webpack生产环境配置</span></div><div class="line">2、config //项目开发环境配置相关代码</div><div class="line"><span class="comment"># dev.env.js=开发环境变量</span></div><div class="line"><span class="comment"># index.js=项目一些配置变量，上线时候的接口可以在这里配置</span></div><div class="line"><span class="comment"># prod.env.js=生产环境变量</span></div><div class="line">3、node_modules //项目所有依赖包的安装文件夹</div><div class="line">4、src //源码目录，也就是你写的代码在这里            5</div><div class="line"><span class="comment"># assets=资源目录（style、iconfonts、公用的varrybel.styl等）</span></div><div class="line"><span class="comment"># common=我自己建的用于存放公用组件的地方</span></div><div class="line"><span class="comment"># router=路由</span></div><div class="line"><span class="comment"># App.vue=项目入口文件</span></div><div class="line"><span class="comment"># main.js=程序入口文件</span></div><div class="line">5、static //静态文件，放一些图片，json数据等</div><div class="line">6、.babelrc //ES6语法编译配置</div><div class="line">7、.editorconfig //定义代码格式</div><div class="line">8、.gitignore //git上传的时候不希望上传的文件格式</div><div class="line">9、 index.html //入口页</div><div class="line">10、package.json //项目基本信息and这个项目所需要的依赖包，npm install的时候会根据这个去安装</div><div class="line">11、README.md //项目的一些说明</div></pre></td></tr></table></figure></p><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>前端路由，就是指向的意思，类似a标签，当我点击某个地方或者链接时显示相应的内容，即Home =&gt; home 内容， detail =&gt; detail。</p><p>路由中有三个基本的概念 route, routes, router<br>1、route，一条路由，home =&gt; home是一条路由，detail =&gt; detail是另一条路由。<br>2、routes 一组路由，就是一条一条路由形成一个数组。[{home =&gt;home}， { detail =&gt; detail}]<br>3、router 一个机制，用来管理路由。routes只是定义了一组静止的路由，当发生请求的时候，也就是当用户触发home的时候，router会到routes中去查找相对应的相对应的内容进行展示<br>构造一组路由：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const routes = [</div><div class="line">  &#123; path: <span class="string">'/home'</span>, component: Home &#125;,</div><div class="line">  &#123; path: <span class="string">'/detail'</span>, component: Detail&#125;</div><div class="line">]</div></pre></td></tr></table></figure></p><p>用构造函数new vueRouter()构建一个router，然后传入routes进行管理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">      routes //key值和value值相等的时候可以只写key值</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>注入根实例之后就可以使用了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const app = new Vue(&#123;</div><div class="line">  router</div><div class="line">&#125;).<span class="variable">$mount</span>(<span class="string">'#app'</span>)</div></pre></td></tr></table></figure></p><p>举例动态路由<br>安装方法移步<a href="https://router.vuejs.org/installation.html#direct-download-cdn" target="_blank" rel="external">vue官网</a>，这是我用的例子，大概结构就是有一个详情页的列表显示不同地方的旅游景点，我需要查看某个列表项的详情，这时候就用到了路由帮我带参数跳转过去，然后看到相应列表项的详情。<br>列表项组件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;div class=<span class="string">"hot-title"</span>&gt;推荐信息&lt;/div&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">&lt;router-link</div><div class="line">tag=<span class="string">"li"</span></div><div class="line">class=<span class="string">"item border-bottom"</span> </div><div class="line">v-for=<span class="string">"item of recommend"</span> </div><div class="line">:key=<span class="string">"item.id"</span></div><div class="line">:to=<span class="string">"'/detail/'+item.id"</span></div><div class="line">&gt;</div><div class="line">&lt;img class=<span class="string">"item-img"</span> :src=<span class="string">"item.imgUrl"</span> alt=<span class="string">""</span>&gt;</div><div class="line">&lt;div class=<span class="string">"item-info"</span>&gt;</div><div class="line">&lt;p class=<span class="string">"item-title"</span>&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt;</div><div class="line">&lt;p class=<span class="string">"item-desc"</span>&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt;</div><div class="line">&lt;button class=<span class="string">"item-button"</span>&gt;查看详情&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/router-link&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p><p>router目录下，index.js文件里头的写法，这是定义路径到组件的映射<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import Vue from <span class="string">'vue'</span></div><div class="line">import Router from <span class="string">'vue-router'</span></div><div class="line">import Home from <span class="string">'@/pages/home/home'</span></div><div class="line">import City from <span class="string">'@/pages/city/city'</span></div><div class="line">import Detail from <span class="string">'@/pages/detail/detail'</span></div><div class="line"></div><div class="line">Vue.use(Router)</div><div class="line"></div><div class="line"><span class="built_in">export</span> default new Router(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: <span class="string">'/'</span>,   </div><div class="line">      name: <span class="string">'Home'</span>,</div><div class="line">      component: Home</div><div class="line">    &#125;，</div><div class="line">    &#123;</div><div class="line">      path:<span class="string">'/detail/:id'</span>,</div><div class="line">      name:<span class="string">"Detail"</span>,</div><div class="line">      component:Detail</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  scrollBehavior (to, from, savedPosition) &#123;</div><div class="line">      <span class="built_in">return</span> &#123; x: 0, y: 0 &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>可以参照<a href="https://github.com/HHardyy/Vue2.0-Travel-App" target="_blank" rel="external">我这个项目</a>的玩法</p><h3 id="router-view以及router-link"><a href="#router-view以及router-link" class="headerlink" title="router-view以及router-link"></a>router-view以及router-link</h3><h3 id="router-view："><a href="#router-view：" class="headerlink" title="router-view："></a>router-view：</h3><p>也就是项目入口文件里的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;keep-alive exclude=<span class="string">"detail"</span>&gt;</div><div class="line">      &lt;router-view/&gt;</div><div class="line">&lt;/keep-alive&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p><p>是个很关键的组件，它就是用来渲染匹配到的路由的。 我这里搭配使用了keep-alive，keep-alive可以缓存数据，这样不至于重新渲染路由组件的时候，组件状态不被保存，也就是说从这个组件跳到其他组件再跳回来的的时候这个组件还是之前的状态</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>router-link是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址，被选中的router-link将自动添加一个class属性值.router-link-active。<br>router-link的一些配置项，用法可以看上面简单的例子</p><h4 id="to-””"><a href="#to-””" class="headerlink" title=":to=””"></a>:to=””</h4><p>使用路由必须设置的属性，否则路由无法生效，可以是一个字符串也可以是一个描述目标位置的对象。</p><h4 id="tag-”li”"><a href="#tag-”li”" class="headerlink" title="tag=”li”"></a>tag=”li”</h4><p>一般router-link默认被渲染成a标签，tag属性可以用来设置router-link会被渲染成什么标签</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>是个Boolean值，默认是false。当replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-link to=<span class="string">"xxx"</span> replace&gt;&lt;/router-link&gt;</div></pre></td></tr></table></figure></p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>Vuex是Vue.js应用程序的状态管理模式+库。作为应用程序中所有组件的集中存储区，并且规则确保只能以可预测的方式对状态进行变更。也就是可以全局数据管理，其实就是一个单向数据的改变流程。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vue-family/vuex.JPG" alt="“根据官网提供的vuex生命周期视图”" title="">                </div>                <div class="image-caption">“根据官网提供的vuex生命周期视图”</div>            </figure><br>1、state：类似vue对象的data, 用来存放数据以及状态。存放的数据为响应式，如果数据改变，那么依赖数据的组件也会发生相应的改变。<br>获取state的两种方式例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.store.getters[<span class="string">'xxx'</span>]</div><div class="line">2. ...mapGetters(&#123;</div><div class="line">        UserInfo: <span class="string">'xxx'</span>, // 用户信息</div><div class="line">        menuList: <span class="string">'xxx'</span>, // approve 运价审批</div><div class="line">        RateUserInfo: <span class="string">'xxxx'</span> // Rate用户信息</div><div class="line">   &#125;)</div><div class="line">可以通过mapState把全局的state和getters映射到当前组件的computed计算属性中。</div></pre></td></tr></table></figure></p><p>2、actions<br>通过store.dispatch方法触发,action支持异步调用（可以调用api），mutation只支持操作同步，并且action提交的是mutation，而不是直接变更状态。Action函数接受一个与store 实例具有相同方法和属性的context对象，因此可以调用context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getters。<br>3、mutation<br>每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数。<br>4、Vuex允许在store中定义“getter”（可以认为是store的计算属性）。就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>举例：为了方便在src目录下新建一个store目录，里头新建一个index.js,然后使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import Vue from <span class="string">'vue'</span></div><div class="line">import Vuex from <span class="string">'vuex'</span>//引入Vuex</div><div class="line"></div><div class="line">Vue.use(Vuex)//让vue使用vuex</div><div class="line"></div><div class="line"><span class="built_in">export</span> default new Vuex.Store(&#123;</div><div class="line">state:&#123;    //全局数据</div><div class="line">key:<span class="string">'value'</span></div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>写完这些之后在main.js里头写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import store from <span class="string">'./store'</span></div><div class="line"></div><div class="line">创建根vue实例的时候和使用vuetouter一样，当key=value的时候只需要写一个就好了</div><div class="line">new Vue(&#123;</div><div class="line">  store</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这样子它就会将数据 自动派发到每个子组件，比如子组件需要使用key的值，可以直接，就ko了。</p><p>假如要改变多个页面的额数据，在上面的基础之上根据官网提供的vuex生命周期触发点击事件的组件里面写这样的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">methods:&#123;</div><div class="line">handelCheckHotcity(city)&#123;</div><div class="line">this.<span class="variable">$store</span>.dispatch(<span class="string">'changeCity'</span>,city)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>store文件下的index.js的公共数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import Vue from <span class="string">'vue'</span></div><div class="line">import Vuex from <span class="string">'vuex'</span></div><div class="line"></div><div class="line">Vue.use(Vuex)</div><div class="line"></div><div class="line"><span class="built_in">export</span> default new Vuex.Store(&#123;</div><div class="line">state:&#123;</div><div class="line">city:<span class="string">'香港'</span></div><div class="line">&#125;,</div><div class="line">actions:&#123;</div><div class="line">changeCity(ctx,city)&#123;       //ctx是上下文，city是传入的参数</div><div class="line">ctx.commit(<span class="string">'changeCity'</span>,city)</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">mutations:&#123;</div><div class="line">changeCity(state,city)&#123;</div><div class="line">state.city=city</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>组件也可以不用先dispatch触发changeCity方法，可以直接commit<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.<span class="variable">$store</span>.commit(<span class="string">'changeCity'</span>,city)</div></pre></td></tr></table></figure></p><p>store文件下的index.js公共数据actions，直接写mutations对象，然后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">changeCity(state,city)&#123;</div><div class="line"> state.city=city</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>vuex还有个好处就是可以在不同组件@click这个方法来对写了vuex逻辑的index.js文件里的数据进行修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handelCheckHotcity(city)&#123;</div><div class="line">this.<span class="variable">$store</span>.dispatch(<span class="string">'changeCity'</span>,city)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios是一个基于Promise用于浏览器和nodejs的HTTP客户端，可以实现跨平台数据请求，node平台上可以发送http请求，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install axios --save</div></pre></td></tr></table></figure></p><p>了解过ajax的道友应该都懂了，这里我在mounted里面触发了一个methods里面的getDetailData方法，向接口请求数据来实现交互效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">getDetailData</span></span>()&#123;</div><div class="line">axios.get(<span class="string">'接口地址'</span>,&#123;</div><div class="line">params:&#123;</div><div class="line">id:this.<span class="variable">$route</span>.params.id</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line">.<span class="keyword">then</span>((res)=&gt;&#123;</div><div class="line">console.log(res)</div><div class="line">&#125;)</div><div class="line">.catch((err)=&gt;&#123;</div><div class="line">console.log(err)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">axios.post(<span class="string">'/user'</span>, &#123;</div><div class="line">    name: <span class="string">'hhardyy'</span>,</div><div class="line">    sex: <span class="string">'male'</span></div><div class="line">  &#125;)</div><div class="line">  .<span class="keyword">then</span>((res)=&gt;&#123;</div><div class="line">    console.log(res)</div><div class="line">&#125;)</div><div class="line">.catch((err)=&gt;&#123;</div><div class="line">console.log(err)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="请求多个并发"><a href="#请求多个并发" class="headerlink" title="请求多个并发"></a>请求多个并发</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserAccount</span></span>() &#123;</div><div class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUserPermissions</span></span>() &#123;</div><div class="line">  <span class="built_in">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">axios.all([getUserAccount(), getUserPermissions()])</div><div class="line">  .<span class="keyword">then</span>(axios.spread(<span class="keyword">function</span> (acct, perms) &#123;</div><div class="line">    // 两个请求现在都执行完成</div><div class="line">  &#125;));</div></pre></td></tr></table></figure><p>最近一直在熬夜，准确的说今年一直在熬夜ლ(′◉❥◉｀ლ)，渐渐觉得深夜才能创造灵感，不过白天眼睛痛~感觉都要开启永恒万花筒写轮眼了~<br><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="external">更多用法可以参照这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue全家桶也就是1.脚手架、2.路由、3.状态管理、4.请求工具~。&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=559931973&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="vue-cli" scheme="http://yoursite.com/tags/vue-cli/"/>
    
      <category term="vue-router" scheme="http://yoursite.com/tags/vue-router/"/>
    
      <category term="vuex" scheme="http://yoursite.com/tags/vuex/"/>
    
      <category term="axios" scheme="http://yoursite.com/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>Vue全家桶开发旅游app</title>
    <link href="http://yoursite.com/2018/06/10/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%BC%80%E5%8F%91%E6%97%85%E6%B8%B8app/"/>
    <id>http://yoursite.com/2018/06/10/Vue全家桶开发旅游app/</id>
    <published>2018-06-09T18:26:24.000Z</published>
    <updated>2018-06-10T10:30:56.901Z</updated>
    
    <content type="html"><![CDATA[<p>vue全家桶做的一个web版旅游app</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=558261233&auto=0&height=66"></iframe><br><a id="more"></a></p><h3 id="css辅助工具依赖包stylus"><a href="#css辅助工具依赖包stylus" class="headerlink" title="css辅助工具依赖包stylus"></a>css辅助工具依赖包stylus</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install stylus --save</div><div class="line">npm install stylus-loader --save</div></pre></td></tr></table></figure><h3 id="首页轮播-第三方插件vue-awesome-swiper-2-6-7稳定版"><a href="#首页轮播-第三方插件vue-awesome-swiper-2-6-7稳定版" class="headerlink" title="首页轮播=第三方插件vue-awesome-swiper,2.6.7稳定版"></a>首页轮播=第三方插件vue-awesome-swiper,2.6.7稳定版</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vue-awesome-swiper@2.6.7 --save</div></pre></td></tr></table></figure><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install axios --save</div></pre></td></tr></table></figure><h3 id="Better-scroll滚屏"><a href="#Better-scroll滚屏" class="headerlink" title="Better-scroll滚屏"></a>Better-scroll滚屏</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm install better-scroll --save</div><div class="line"></div><div class="line"><span class="keyword">if</span>(this.latter)&#123;</div><div class="line">    this.scroll.scrollToElement()</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="手指滑动事件"><a href="#手指滑动事件" class="headerlink" title="手指滑动事件"></a>手指滑动事件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">touchstart</div><div class="line">touchmove</div><div class="line">touchend</div><div class="line"></div><div class="line">函数节流，限制执行效率touchmove执行效率过高了</div><div class="line">ref=<span class="string">"xxx"</span></div><div class="line">import bscroll from <span class="string">'better-scroll'</span></div><div class="line"><span class="function"><span class="title">mounted</span></span>()&#123;</div><div class="line">this.bscroll=new bscroll(this.<span class="variable">$refs</span>.xxx)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="解决的一些问题"><a href="#解决的一些问题" class="headerlink" title="解决的一些问题:"></a>解决的一些问题:</h2><h3 id="pagination分页"><a href="#pagination分页" class="headerlink" title="pagination分页"></a>pagination分页</h3><p>移步swiper中文网<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">解决swiper加载之前，gallary组件先渲染导致banner的时候出现bug的问题</div><div class="line">搜observeParents以及observer意思是当父组件dom刷新的时候，swiper重新刷新一次</div><div class="line">observeParents:<span class="literal">true</span></div><div class="line">observer：<span class="literal">true</span></div></pre></td></tr></table></figure></p><h3 id="对全局事件的解绑"><a href="#对全局事件的解绑" class="headerlink" title="对全局事件的解绑"></a>对全局事件的解绑</h3><p>由于使用了keep-alive产生的生命周期钩子activated，绑定的事件处理函数是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(<span class="string">'scroll'</span>, this.handelScroll)</div></pre></td></tr></table></figure></p><p>因为绑定的是window对象，这样不光本页滚动会触发该事件处理函数，回到主页也会触发该事件处理函数，所以是默默的写了一个影响引擎的错误。<br>全局解绑就是deactivated，在上面那个方法后面加上这个方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.removeEventListener(<span class="string">'scroll'</span>, this.handelScroll)</div></pre></td></tr></table></figure></p><p>它会在页面重新加载的时候重新加载事件处理函数</p><h3 id="APP-vue对路由下的组件避免缓存"><a href="#APP-vue对路由下的组件避免缓存" class="headerlink" title="APP.vue对路由下的组件避免缓存"></a>APP.vue对路由下的组件避免缓存</h3><p>可以加上exclude，对其中的某个组件进行避免缓存，这样其mounted方法就不会一直缓存在同一个状态，导致路由跳转的状态不变从而axios获取数据的时候key值不被改变<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;keep-alive exclude=<span class="string">"detail"</span>&gt;</div><div class="line">      &lt;router-view/&gt;</div><div class="line">&lt;/keep-alive&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p><h3 id="移动端使用click会延迟300毫秒之后才执行"><a href="#移动端使用click会延迟300毫秒之后才执行" class="headerlink" title="移动端使用click会延迟300毫秒之后才执行"></a>移动端使用click会延迟300毫秒之后才执行</h3><p>解决：引入faserclick<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install fastclick --save</div></pre></td></tr></table></figure></p><p>把这个包安装到项目依赖，因为线上线下都要用就–save保存到package.json<br>项目入口文件里<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import FastClick from <span class="string">'fastclick'</span></div><div class="line">FastClick.attach(document.body)</div></pre></td></tr></table></figure></p><h3 id="git-push之后的这个问题"><a href="#git-push之后的这个问题" class="headerlink" title="git push之后的这个问题"></a>git push之后的这个问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">....... ....  hhardyy/Travel (master|MERGING)</div></pre></td></tr></table></figure><p>原因是可能同时上传了更新的文件导致冲突，这时候可以查看一下工作目录里面“README.md”文件的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  </div><div class="line">这是第二个人提交的......................  </div><div class="line">=======  </div><div class="line">这是第一个人提交的  </div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master</div></pre></td></tr></table></figure></p><p>这时候git status查看哪个文件有报错，去到那个文件里面把多余的类似于&gt;&gt;&gt; head的代码干掉，重新add .然后提交就ok了</p><h3 id="阻止页面默认行为"><a href="#阻止页面默认行为" class="headerlink" title="阻止页面默认行为"></a>阻止页面默认行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">修复bug：在城市选择选择页从字母上滚动的时候屏幕默认会跟着上下移动，需要的效果是手指从字母上移动的时候根据移动到的字母左边显示出相应字母开头拼音的城市</div><div class="line">@touchstart.prevent=<span class="string">"handelTouchStart"</span></div><div class="line">.prevent=事件修饰符，可以阻止页面默认行为</div></pre></td></tr></table></figure><h3 id="真机测试的时候有些浏览器默认不支持promise"><a href="#真机测试的时候有些浏览器默认不支持promise" class="headerlink" title="真机测试的时候有些浏览器默认不支持promise"></a>真机测试的时候有些浏览器默认不支持promise</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">安装这个依赖</div><div class="line">npm install babel-polyfill --save</div></pre></td></tr></table></figure><p>它会判断浏览器如果没有promise，会自动增加这个es6的新特性<br>进入入口文件main.js里头import ‘babel-polyfill’在所有浏览器上就都支持promise了，以及解决部分白屏问题。<br><a href="https://github.com/HHardyy/Vue2.0-Travel-App" target="_blank" rel="external">项目地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue全家桶做的一个web版旅游app&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=558261233&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="app" scheme="http://yoursite.com/tags/app/"/>
    
  </entry>
  
  <entry>
    <title>vue组件通信</title>
    <link href="http://yoursite.com/2018/05/19/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2018/05/19/vue组件通信/</id>
    <published>2018-05-18T16:56:35.000Z</published>
    <updated>2018-07-04T09:58:49.551Z</updated>
    
    <content type="html"><![CDATA[<p>这里我没用脚手架，可以用html和js的思维了解，最重要的是这次的音乐是我最喜欢的Flower Dance</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=420401412&auto=0&height=66"></iframe><br><a id="more"></a><br>据说父子组件通信很难理解，瑟瑟发抖的写一下<br>先说它们的通信方式不是移动联通电信~</p><h3 id="父组件把数据传给子组件用props"><a href="#父组件把数据传给子组件用props" class="headerlink" title="父组件把数据传给子组件用props"></a>父组件把数据传给子组件用props</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/props_img/props.JPG" alt="“props的一些属性”" title="">                </div>                <div class="image-caption">“props的一些属性”</div>            </figure> <p>用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//subassembly是一个注册了的子组件</div><div class="line"> &lt;subassembly v-for=<span class="string">"(item,index) in list"</span> :content=<span class="string">"item"</span>&gt;&lt;/subassembly&gt;</div><div class="line"> Vue.component(<span class="string">'subassembly'</span>, &#123;</div><div class="line">        props: [<span class="string">'content'</span>],</div><div class="line">        template: <span class="string">'&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;'</span></div><div class="line">&#125;);</div><div class="line">item是父组件v-for循环出来的东西</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/props_img/1.png" alt="“拿到父组件循环的item数据显示”" title="">                </div>                <div class="image-caption">“拿到父组件循环的item数据显示”</div>            </figure>  <p>这个会做成单独的组件是为了应付数据多的时候单独做成一个组件比较好</p><h3 id="子组件可以使用-emit-触发父组件的自定义事件-也可以用on事件监听"><a href="#子组件可以使用-emit-触发父组件的自定义事件-也可以用on事件监听" class="headerlink" title="子组件可以使用 $emit 触发父组件的自定义事件,也可以用on事件监听"></a>子组件可以使用 $emit 触发父组件的自定义事件,也可以用on事件监听</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm.<span class="variable">$emit</span>( event, arg ) //触发当前实例上的事件处理函数</div><div class="line">vm.<span class="variable">$on</span>( event, func ) //监听event事件后执行事件处理函数</div></pre></td></tr></table></figure><p>这里用$emit举例假如要删掉生成的数据，这时候需要在子组件写这样的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'subassembly'</span>, &#123;</div><div class="line">        props: [<span class="string">'content'</span>, <span class="string">'index'</span>],</div><div class="line">        template: <span class="string">'&lt;li @click="handleFunction"&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;'</span>,</div><div class="line">        methods: &#123;</div><div class="line">            handleFunction: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">                this.<span class="variable">$emit</span>(<span class="string">'delete'</span>, this.index)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>这样子组件被点击的时候就会触发delete,此时父组件v-on了一个delete触发父组件的delfunction方法，并且传过去一个index<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;subassembly</div><div class="line">        v-for=<span class="string">"(item,index) in list"</span> :key=<span class="string">"index"</span> :content=<span class="string">"item"</span></div><div class="line">        :index=<span class="string">"index"</span></div><div class="line">        @delete=<span class="string">"delfunction"</span>&gt;</div><div class="line">&lt;/subassembly&gt;</div><div class="line"></div><div class="line">Vue.component(<span class="string">'subassembly'</span>, &#123;</div><div class="line">        props: [<span class="string">'content'</span>, <span class="string">'index'</span>],</div><div class="line">        template: <span class="string">'&lt;li @click="handleFunction"&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;'</span>,</div><div class="line">        methods: &#123;</div><div class="line">            handleFunction: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">                this.<span class="variable">$emit</span>(<span class="string">'delete'</span>, this.index)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p><p>delfunction：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">delfunction: <span class="keyword">function</span> (index) &#123;</div><div class="line">        alert(<span class="string">"删掉了"</span>);</div><div class="line">        this.list.splice(index, 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>父组件接收到子组件传过来的index之后就删掉相应数据，vue是数据驱动的，这么干就实现了删除功能<br>有点绕。</p><h3 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h3><p>非父子组件通信可以用vuex和下面举例的这个方法，当然一般用vuex比较好。<br>官网的api指出可以使用空vue实例作为事件中央线！也就是说非父子组件之间的通信，必须要有公共的实例（可以是空的），才能使用 $emit 获取 $on 的数据参数，实现组件通信。<br>比如现在创建了cail组件，希望让他们的值可以互传<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;cail content=<span class="string">"brother1"</span>&gt;&lt;/cail&gt;</div><div class="line">&lt;cail content=<span class="string">"brother2"</span>&gt;&lt;/cail&gt;</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/props_img/2.JPG" alt="“效果图”" title="">                </div>                <div class="image-caption">“效果图”</div>            </figure>  <p>先定义一个公共的中央线<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.bus = new Vue();</div></pre></td></tr></table></figure></p><p>给组件绑定上一个sonclick事件，然后通过$emit传参<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sonhandl: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    this.bus.<span class="variable">$emit</span>(<span class="string">'sonclick'</span>, this.soncontent);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为vue是单向数据流关系，不允许子修改父组件的数据，虽然不会报错，但是会报警告，所以在声明子组件的时候只能定义一个soncontent来装父级传过来的content。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> &#123;</div><div class="line">        soncontent: this.content</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>接着用钩子函数通过$on监听sonclick事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mounted: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    var this_ = this;</div><div class="line">    this.bus.<span class="variable">$on</span>(<span class="string">'sonclick'</span>, <span class="keyword">function</span> (msg) &#123;</div><div class="line">        this_.soncontent = msg;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>这样就实现了点击brother1的时候，组件值也传到brother2<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/props_img/3.JPG" alt="“效果”" title="">                </div>                <div class="image-caption">“效果”</div>            </figure>  </p><p>理解简单点就是兄组件绑定一个handelFunction<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div @click=<span class="string">"handelFunction"</span>&gt;&lt;/div&gt;</div><div class="line">methods: &#123;</div><div class="line">    <span class="function"><span class="title">handelFunction</span></span>() &#123;</div><div class="line">        vm.<span class="variable">$emit</span>(<span class="string">'hanFunction'</span>,<span class="string">'HHardyy'</span>); //触发事件</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>弟组件on监听hanFunction<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">created</span></span>() &#123;</div><div class="line">  vm.<span class="variable">$on</span>(<span class="string">'hanFunction'</span>, (re) =&gt; &#123; </div><div class="line">        this.test= re; // 接收HHardyy</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里我没用脚手架，可以用html和js的思维了解，最重要的是这次的音乐是我最喜欢的Flower Dance&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=420401412&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="props" scheme="http://yoursite.com/tags/props/"/>
    
      <category term="$emit" scheme="http://yoursite.com/tags/emit/"/>
    
      <category term="$on" scheme="http://yoursite.com/tags/on/"/>
    
      <category term="父子组件通信" scheme="http://yoursite.com/tags/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="非父子组件通信" scheme="http://yoursite.com/tags/%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>ES6的基本玩法</title>
    <link href="http://yoursite.com/2018/05/13/ES6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8E%A9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/13/ES6的基本玩法/</id>
    <published>2018-05-13T15:03:26.000Z</published>
    <updated>2018-05-13T16:36:25.227Z</updated>
    
    <content type="html"><![CDATA[<p>ES6是下一代JavaScript语言标准的统称，每年6月发布一次修订版，迄今为止已经发布了3个版本，分别是ES2015、ES2016、ES2017。<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=526068535&auto=0&height=66"></iframe><a id="more"></a><br>最近一边玩linux一边玩网络安全，今天突然闲下来更新一下blog，写一下ES6。ES6（ECMAScript6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。Mozilla公司将在这个标准的基础上，推出JavaScript 2.0。</p><h3 id="ECMAScript和JavaScript到底是什么关系？"><a href="#ECMAScript和JavaScript到底是什么关系？" class="headerlink" title="ECMAScript和JavaScript到底是什么关系？"></a>ECMAScript和JavaScript到底是什么关系？</h3><p>简单来说，ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是,它声明的变量只能是全局或者整个函数块的。<br>let与var的区别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">var a = 100;</div><div class="line"><span class="built_in">let</span> b = 200;</div><div class="line">&#125;</div><div class="line">console.log(a);//100</div><div class="line">console.log(b);//b </div><div class="line">is not defined -- Error</div></pre></td></tr></table></figure></p><p>let不存在变量提升<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//ES5****************************</div><div class="line">var a = [];</div><div class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">var c = i;</div><div class="line">a[i] = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">console.log(c);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">a[5]();//9</div><div class="line">//ES6**************************</div><div class="line">var b = [];</div><div class="line"><span class="keyword">for</span> (var j = 0; j &lt; 10; j++) &#123;</div><div class="line"><span class="built_in">let</span> d = j;</div><div class="line">b[j] = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">console.log(d);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">b[5]();//5</div></pre></td></tr></table></figure></p><p>let不受外界影响<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = 100;</div><div class="line">&#123;</div><div class="line">console.log(a);//undefined</div><div class="line"><span class="built_in">let</span> a = 100;</div><div class="line">console.log(a);//100</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>let不允许重复声明<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">var a = 100;</div><div class="line">var a = 200;</div><div class="line">console.log(a);</div><div class="line">&#125;// 报错</div><div class="line">模块内也不允许重复声明</div></pre></td></tr></table></figure></p><p>块级作用域<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">console.log(<span class="string">"ES5:"</span>);</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">var num = 100;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">var num = 200;</div><div class="line">&#125;;</div><div class="line">console.log(num);</div><div class="line">&#125;;</div><div class="line">fun();//200</div><div class="line">**********************************************</div><div class="line">console.log(<span class="string">"ES6:"</span>);</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line"><span class="built_in">let</span> num = 100;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"><span class="built_in">let</span> num = 200;</div><div class="line">&#125;;</div><div class="line">console.log(num);</div><div class="line">&#125;;</div><div class="line">fun();//100</div></pre></td></tr></table></figure></p><p>立即执行函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">console.log(<span class="string">"ES5:"</span>);</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">console.log(<span class="string">"I am outside!"</span>);</div><div class="line">&#125;;</div><div class="line">(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">console.log(<span class="string">"I am inside!"</span>);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">fun();</div><div class="line">&#125;());</div><div class="line">******************************************</div><div class="line">console.log(<span class="string">"ES6:"</span>);</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">console.log(<span class="string">"I am outside!"</span>);</div><div class="line">&#125;;</div><div class="line">(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">console.log(<span class="string">"I am inside!"</span>);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">fun();</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p><p>立即执行函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">console.log(<span class="string">"ES5:"</span>);</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">console.log(<span class="string">"I am outside!"</span>);</div><div class="line">&#125;;</div><div class="line">(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">console.log(<span class="string">"I am inside!"</span>);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">fun();</div><div class="line">&#125;());</div><div class="line">******************************************</div><div class="line">console.log(<span class="string">"ES6:"</span>);</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">console.log(<span class="string">"I am outside!"</span>);</div><div class="line">&#125;;</div><div class="line">(<span class="function"><span class="title">function</span></span> () &#123;</div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</div><div class="line">console.log(<span class="string">"I am inside!"</span>);</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">fun();</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const Pi = 3.1415926535;<br>声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，必须在声明的同一语句中指定它的值。<br>const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。另外常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p><p>const块级作用域<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">const Pi = 3.14159265;</div><div class="line">&#125;;</div><div class="line">console.log(Pi);//Pi is not defined</div></pre></td></tr></table></figure></p><p>const暂时性死区<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">console.log(Pi);//undefined</div><div class="line">const Pi = 3.14159265;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>const不可重复声明<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">var a   = 100;</div><div class="line">const a = 200;</div><div class="line">console.log(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>const对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const person = &#123;&#125;;</div><div class="line">person.name  = <span class="string">"hhardyy"</span>;</div><div class="line">person.age   = 22;</div><div class="line">console.log(person.name);//hhardyy</div><div class="line">console.log(person.age);//22</div><div class="line">console.log(person);//Object &#123;name: <span class="string">"hhardyy"</span>, age: 22&#125;</div></pre></td></tr></table></figure></p><p>const对象错误方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const person = &#123;&#125;;</div><div class="line">person.name  = <span class="string">"hhardyy"</span>;</div><div class="line">person.age   = 22;</div><div class="line">console.log(person.name);</div><div class="line">console.log(person.age);</div><div class="line">console.log(person);</div><div class="line">person = &#123;&#125;;//person is <span class="built_in">read</span>-only</div></pre></td></tr></table></figure></p><p>const数组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const arr = [];</div><div class="line">console.log(arr);</div><div class="line">console.log(arr.length);</div><div class="line">**********************************</div><div class="line">arr.push(<span class="string">"Hello world!"</span>);</div><div class="line">console.log(arr);</div><div class="line">console.log(arr.length);</div><div class="line">**********************************</div><div class="line">arr.length = 0;</div><div class="line">console.log(arr);</div><div class="line">console.log(arr.length);// 错误用法</div><div class="line">arr = [<span class="string">"Hello Everyone!"</span>];</div></pre></td></tr></table></figure></p><p>const对象冻结<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const person = Object.freeze(&#123;&#125;);</div><div class="line">person.name  = <span class="string">"hhardyy"</span>;</div><div class="line">person.age   = 22;</div><div class="line">console.log(person.name);//undefined</div><div class="line">console.log(person.age);//undefined</div><div class="line">console.log(person);//Object</div></pre></td></tr></table></figure></p><p>使用const对象冻结<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const person = Object.freeze(&#123;</div><div class="line">name: <span class="string">"hhardyy"</span>,</div><div class="line">age : 22</div><div class="line">&#125;);</div><div class="line">console.log(person.name);//hhardyy</div><div class="line">console.log(person.age);//22</div><div class="line">console.log(person);//Object</div></pre></td></tr></table></figure></p><h3 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">   //module.js</div><div class="line"><span class="built_in">export</span> const intVariantName = 100;</div><div class="line"><span class="built_in">export</span> const FloatVariantName = 3.14159165;</div><div class="line"><span class="built_in">export</span> const charVariantName = <span class="string">"variantValue"</span>;</div><div class="line">//use.js</div><div class="line">import * as variant from <span class="string">'./module'</span>;</div><div class="line">console.log(variant.intVariantName);//100</div><div class="line">console.log(variant.FloatVariantName);//3.14159165</div><div class="line">console.log(variant.charVariantName);//variantValue</div><div class="line">//otherUse.js</div><div class="line">import &#123; FloatVariantName, charVariantName &#125; as variant from <span class="string">'./module'</span>;</div><div class="line">console.log(variant.FloatVariantName);//3.14159165</div><div class="line">console.log(variant.charVariantName);//variantValue</div><div class="line">//OnlyInt.js</div><div class="line">import intVariantName as variant from <span class="string">'./module'</span>;</div><div class="line">console.log(variant.intVariantName);//100</div></pre></td></tr></table></figure><h3 id="全局变量属性"><a href="#全局变量属性" class="headerlink" title="全局变量属性"></a>全局变量属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var varName = <span class="string">"varValue"</span>;</div><div class="line">//浏览器环境下</div><div class="line">console.log(window.varName);//varValue</div><div class="line">//Node.js环境下</div><div class="line">//console.log(global.varName);//varValue</div><div class="line">//通用环境</div><div class="line">console.log(this.varName);//varValue</div><div class="line"><span class="built_in">let</span> letName = <span class="string">"letValue"</span>;</div><div class="line">console.log(window.letName);//undefined -- use strict</div><div class="line">console.log(this.letName);//undefined -- use strict</div></pre></td></tr></table></figure><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>数组解构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var [a, b, c] = [1, 2, 3];</div><div class="line">console.log(a);//1</div><div class="line">console.log(b);//2</div><div class="line">console.log(c);//3</div></pre></td></tr></table></figure></p><p>对应位置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> [foo, [[bar], base]] = [1, [[2], 3]];</div><div class="line">console.log(foo);//1</div><div class="line">console.log(bar);//2</div><div class="line">console.log(base);//3</div><div class="line"><span class="built_in">let</span> [, , third] = [<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>];</div><div class="line">console.log(third);//third</div><div class="line"><span class="built_in">let</span> [one, , three] = [<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>];</div><div class="line">console.log(one);//One</div><div class="line">console.log(three);//Three</div><div class="line"><span class="built_in">let</span> [head, ...tail] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</div><div class="line">console.log(head);//0</div><div class="line">console.log(tail);//[1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure></p><p>数组解构不成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   var [temp] = [];</div><div class="line">console.log(temp);//undefined</div><div class="line">var [first, second] = [100];</div><div class="line">console.log(first);//100</div><div class="line">console.log(second);//undefined</div></pre></td></tr></table></figure></p><p>不完全解构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> [x, y] = [1, 2, 3];</div><div class="line">console.log(x);//1</div><div class="line">console.log(y);//2</div><div class="line"><span class="built_in">let</span> [a, [b], c] = [1, [2, 3], 4];</div><div class="line">console.log(a);//1</div><div class="line">console.log(b);//2</div><div class="line">console.log(c);//4</div></pre></td></tr></table></figure></p><p>制定默认值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var [temp = <span class="string">"string"</span>] = [];</div><div class="line">console.log(temp);//string</div><div class="line">var [temp = <span class="string">"string"</span>] = [<span class="string">"tempString"</span>];</div><div class="line">console.log(temp);//tempString</div><div class="line">var [x = <span class="string">"aaa"</span>, y] = [<span class="string">"bbb"</span>];</div><div class="line">console.log(x);//bbb</div><div class="line">console.log(y);//undefined</div><div class="line">var [m, n = <span class="string">"aaa"</span>] = [<span class="string">"bbb"</span>];</div><div class="line">console.log(m);//bbb</div><div class="line">console.log(n);//aaa</div><div class="line">var [p, q = <span class="string">"aaa"</span>] = [<span class="string">"bbb"</span>, undefined];</div><div class="line">console.log(p);//bbb</div><div class="line">console.log(q);//aaa</div></pre></td></tr></table></figure></p><p>非遍历结构–报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var [temp] = 1;//1[Symbol.iterator] is not a <span class="keyword">function</span> at <span class="built_in">eval</span></div><div class="line">var [temp] = <span class="literal">false</span>;//<span class="literal">false</span>[Symbol.iterator] is not a <span class="keyword">function</span> at <span class="built_in">eval</span></div><div class="line">var [temp] = NaN;//NaN[Symbol.iterator] is not a <span class="keyword">function</span> at <span class="built_in">eval</span></div><div class="line">var [temp] = undefined; //Cannot <span class="built_in">read</span> property <span class="string">'Symbol(Symbol.iterator)'</span> of undefined at <span class="built_in">eval</span></div><div class="line">var [temp] = null;//Cannot <span class="built_in">read</span> property <span class="string">'Symbol(Symbol.iterator)'</span> of null at <span class="built_in">eval</span></div></pre></td></tr></table></figure></p><p>Iterator接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> [a, b, c] = new Set([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</div><div class="line">console.log(a);//a</div><div class="line">console.log(b);//b</div><div class="line">console.log(c);//c</div><div class="line"><span class="keyword">function</span>* <span class="function"><span class="title">fibs</span></span>() &#123;</div><div class="line"><span class="built_in">let</span> a = 0;</div><div class="line"><span class="built_in">let</span> b = 1;</div><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">yield a;</div><div class="line">[a, b] = [b, a + b];</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">var [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line">console.log(sixth);//5</div></pre></td></tr></table></figure></p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>对象的解构赋值不需要按照顺序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &#123; name, age &#125; = &#123; name: <span class="string">"Conan"</span>, age: 28 &#125;;</div><div class="line">console.log(name);//Conan</div><div class="line">console.log(age);//28</div></pre></td></tr></table></figure></p><p>变量名与属性名不一致<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// var &#123; person_name, person_age, person_id &#125; = &#123; id: <span class="string">"007"</span>, name: <span class="string">"Conan"</span>, age: 28 &#125;;</div><div class="line">// console.log(person_name);//undefined</div><div class="line">// console.log(person_age);//undefined</div><div class="line">// console.log(person_id);//undefined</div><div class="line">var &#123; name: person_name, age: person_age, id: person_id &#125; = &#123; id: <span class="string">"007"</span>, name: <span class="string">"Conan"</span>, age: 28 &#125;;</div><div class="line">console.log(person_name);//Conan</div><div class="line">console.log(person_age);//28</div><div class="line">console.log(person_id);//007</div><div class="line"><span class="built_in">let</span> object = &#123; first: <span class="string">"Hello"</span>, last: <span class="string">"World"</span> &#125;;</div><div class="line"><span class="built_in">let</span> &#123; first: firstName, last: lastName&#125; = object;</div><div class="line">console.log(firstName);//Hello</div><div class="line">console.log(lastName);//World</div></pre></td></tr></table></figure></p><p>对象解构默认值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var &#123; x = 3 &#125; = &#123;&#125;;</div><div class="line">console.log(x);//3</div><div class="line">var &#123; x, y = 5 &#125; = &#123; x: 1 &#125;;</div><div class="line">console.log(x);//1</div><div class="line">console.log(y);//5</div><div class="line">var &#123; message: msg = <span class="string">"You Are A Person!"</span> &#125; = &#123;&#125;;</div><div class="line">console.log(msg);//You Are A Person!</div></pre></td></tr></table></figure></p><p>对象解构默认值条件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var &#123; x = 3 &#125; = &#123; x: undefined &#125;;</div><div class="line">console.log(x);//3</div><div class="line">var &#123; y = 3 &#125; = &#123; y: null &#125;;</div><div class="line">console.log(y);//null</div></pre></td></tr></table></figure></p><p>已声明变量的解构赋值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var x;</div><div class="line">(&#123;x&#125; = &#123; x: 1 &#125;);</div><div class="line">console.log(x);//1</div></pre></td></tr></table></figure></p><p>现有对象的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(Math.sin(Math.PI/6));//0.49999999999999994</div><div class="line"><span class="built_in">let</span> &#123; sin, cos, tan, <span class="built_in">log</span> &#125; = Math;</div><div class="line">console.log(sin(Math.PI/6));//0.49999999999999994</div></pre></td></tr></table></figure></p><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const [ a, b, c, d, e ] = <span class="string">"Hello"</span>;</div><div class="line">console.log(a);//H</div><div class="line">console.log(b);//e</div><div class="line">console.log(c);//l</div><div class="line">console.log(d);//l</div><div class="line">console.log(e);//o</div></pre></td></tr></table></figure><p>字符串的属性解构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const &#123; length: len &#125; = <span class="string">"Hello"</span>;</div><div class="line">console.log(len);//5</div><div class="line">const &#123; length &#125; = <span class="string">"Hello World!"</span>;</div><div class="line">console.log(length);//12</div></pre></td></tr></table></figure></p><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> sum([x, y]) &#123;</div><div class="line"><span class="built_in">return</span> x + y;</div><div class="line">&#125;;</div><div class="line">console.log(sum([1, 2]));//3</div></pre></td></tr></table></figure><p>函数参数解构赋值的默认值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> fun (&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</div><div class="line"><span class="built_in">return</span> [x, y];</div><div class="line">&#125;;</div><div class="line">console.log(fun(&#123;x: 100, y: 200&#125;));//[100, 200]</div><div class="line">console.log(fun(&#123;x: 100&#125;));//[100, 0]</div><div class="line">console.log(fun(&#123;&#125;));//[0, 0]</div><div class="line">console.log(fun());//[0, 0]</div></pre></td></tr></table></figure></p><p>函数参数解构赋值的默认值undefined<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> fun (&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</div><div class="line"><span class="built_in">return</span> [x, y];</div><div class="line">&#125;;</div><div class="line">console.log(fun(&#123;x: 100, y: 200&#125;));//[100, 200]</div><div class="line">console.log(fun(&#123;x: 100&#125;));//[100, undefined]</div><div class="line">console.log(fun(&#123;&#125;));//[undefined, undefined]</div><div class="line">console.log(fun());//[0, 0]</div></pre></td></tr></table></figure></p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>Arrow Function（箭头函数）。<br>为什么叫Arrow Function？因为它的定义用的就是一个箭头：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x =&gt; x * x</div></pre></td></tr></table></figure></p><p>相当于ES5的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> (x) &#123;</div><div class="line">    <span class="built_in">return</span> x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="有些浏览器不支持箭头函数，测试方法"><a href="#有些浏览器不支持箭头函数，测试方法" class="headerlink" title="有些浏览器不支持箭头函数，测试方法"></a>有些浏览器不支持箭头函数，测试方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'use strict'</span>;//使用严格模式</div><div class="line">var fn = x =&gt; x * x;</div><div class="line">console.log(<span class="string">'浏览器不支持'</span>);</div></pre></td></tr></table></figure><p>普通函数中的this:<br>1.this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.function ,那么function中的this就指向obj<br>2.在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window<br>3.在严格模式下,没有直接调用者的函数中的this是undefined<br>4.使用call,apply,bind(ES5新增)绑定的,this指的是绑定的对象</p><p>箭头函数中的this<br>没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; </p><h3 id="ES6加入了新的数据类型Symbol与新的数据结构set、map。"><a href="#ES6加入了新的数据类型Symbol与新的数据结构set、map。" class="headerlink" title="ES6加入了新的数据类型Symbol与新的数据结构set、map。"></a>ES6加入了新的数据类型Symbol与新的数据结构set、map。</h3><p>symbol最大的特点是唯一性，symbol不能隐式的转换类型，所以和其他数类型数据做运算时会报错。但是，symbol可以显式地转为字符串和布尔类型。对象object，在添加symbol类型属性时，必须用[]外扩symbol，不能用点式法对其进行操作。如同其他类型数据一般，symbol也有一些内置方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> a=Symbol();</div><div class="line">console.log(typeof a);//symbol,js语言的数据类型再添一员</div></pre></td></tr></table></figure></p><p>Symbol不是一个构造函数，如果new Symbol会报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var sym1 = Symbol();</div><div class="line">var sym2 = Symbol(<span class="string">"foo"</span>);</div><div class="line">var sym3 = Symbol(<span class="string">"foo"</span>);</div><div class="line">console.log(sym1, sym2, sym3) //输出Symbol() Symbol(foo) Symbol(foo)</div><div class="line">用同样的参数创建两次， 也是不相等的：</div><div class="line">Symbol(<span class="string">"foo"</span>) === Symbol(<span class="string">"foo"</span>); //输出：<span class="literal">false</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">let</span> a=Symbol();</div><div class="line"><span class="built_in">let</span> b=Symbol();</div><div class="line">console.log(a);//Symbol()</div><div class="line">console.log(b);//Symbol(),a与b虽然不相等，但是打印出的数据却是一样的，为了区分他们，可以传参：</div><div class="line"><span class="built_in">let</span> c=Symbol(<span class="string">'ccc'</span>);//Symbol(ccc),传入的参数仅做标记，没有任何实际意义</div></pre></td></tr></table></figure></p><p>symbol类型的数据不能与其他类型的数据进行运算，它可以转为string与boolean类型，但是不能转换为number类型，</p><h3 id="数据结构Set。"><a href="#数据结构Set。" class="headerlink" title="数据结构Set。"></a>数据结构Set。</h3><p>类似于数组，只不过其成员值都是唯一的，没有重复的值，向Set加入值的时候，不会发生类型转换。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Set本身是一个构造函数，用来生成Set数据结构。</div><div class="line">var s = new Set();</div><div class="line">// 通过add方法向Set结构中加入成员</div><div class="line">[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x))</div><div class="line"><span class="keyword">for</span> (i of s) &#123; console.log(i) &#125;</div><div class="line">// 2 3 4 5 （表明<span class="built_in">set</span>结构不会添加重复的值）</div><div class="line"></div><div class="line">Set结构接收一个数组作为参数，用来初始化。</div><div class="line">var items = new Set([1, 2, 3, 4, 5, 5, 5]);</div><div class="line">items.size </div><div class="line">// 5</div></pre></td></tr></table></figure></p><h3 id="set的四个方法："><a href="#set的四个方法：" class="headerlink" title="set的四个方法："></a>set的四个方法：</h3><p>add(value) : 添加value。<br>delete(value) : 删除value。<br>has(value) : 返回一个布尔值，表示该值是否为Set的成员。<br>clear() : 清除所有成员。</p><h3 id="数据结构Map"><a href="#数据结构Map" class="headerlink" title="数据结构Map"></a>数据结构Map</h3><p>Js对象本质上是键值对的集合。但是只能使用字符串充当键。ES6为了解决这个问题提供了Map结构。它类似对象，也是键值对集合，但是”键”的范围不限于字符串，对象也可以当作键。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var data = &#123;&#125;;</div><div class="line">var el = document.getElementById(<span class="string">"Div"</span>);</div><div class="line">// 将DOM节点el当做对象data的键，但是对象只接受字符串作为键名，所以el被自动转换为字符串<span class="string">"[Object HTMLDivElement]"</span></div><div class="line">data[el] = metadata;</div><div class="line"></div><div class="line">//map下</div><div class="line">var m = new Map();</div><div class="line">o = &#123;p: <span class="string">"hello world"</span>&#125;;</div><div class="line">m.set(o, <span class="string">"content"</span>);//o作为m的一个键</div><div class="line">console.log( m.get(o) );  // content</div></pre></td></tr></table></figure></p><p>Map函数可接收一个数组进行初始化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var map = new Map([[<span class="string">"name"</span>, <span class="string">"hhardyy"</span>], [<span class="string">"title"</span>, <span class="string">"hhardyytitle"</span>]]);</div></pre></td></tr></table></figure></p><p>Map的6种方法：<br>size : 返回成员总数。<br>set(key, value) : 设置一个键值对。<br>get(key) : 读取一个键。<br>has(key) : 返回一个布尔值，表示某个键是否在Map结构中。<br>delete(key) : 删除某个键。<br>clear() : 清除所有成员。</p><p>Map原生提供三个遍历器。<br>key() : 返回键名的遍历器。<br>values() : 返回键值的遍历器。<br>entries() : 返回所有成员的遍历器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( <span class="built_in">let</span> key of map.key() ) &#123;</div><div class="line">    console.log(<span class="string">"key: %s"</span>, key);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> ( <span class="built_in">let</span> value of map.value() ) &#123;</div><div class="line">    console.log(<span class="string">"value: %s"</span>, value);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> ( <span class="built_in">let</span> item of map.entries() ) &#123;</div><div class="line">    console.log(<span class="string">"Key: %s, Value: %s"</span>, item[0], item[1]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of map) &#123;</div><div class="line">    console.log(<span class="string">"Key: %s, Value: %s"</span>, item[0], item[1]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Map还有一个forEach方法，与数组中的forEach方法类似，也可以实现遍历。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">map.forEach(<span class="keyword">function</span>(value, key, map) &#123;</div><div class="line">    console.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>forEach方法还可接受第二个参数，用来绑定this。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var reporter = &#123;</div><div class="line">    report: <span class="keyword">function</span>(key, value) &#123;</div><div class="line">        console.log(<span class="string">"key: %s, Value: %s"</span>, key, value);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">map.forEach(<span class="keyword">function</span>(value, key, map) &#123;</div><div class="line">    this.report(key, value)</div><div class="line">&#125;, reporter);</div><div class="line">forEach()方法的回调函数中的this, 就指向reporter</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6是下一代JavaScript语言标准的统称，每年6月发布一次修订版，迄今为止已经发布了3个版本，分别是ES2015、ES2016、ES2017。&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=526068535&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="let" scheme="http://yoursite.com/tags/let/"/>
    
      <category term="const" scheme="http://yoursite.com/tags/const/"/>
    
      <category term="箭头函数" scheme="http://yoursite.com/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
      <category term="symbol" scheme="http://yoursite.com/tags/symbol/"/>
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>网络安全之数据包截取原理</title>
    <link href="http://yoursite.com/2018/04/11/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8C%85%E6%88%AA%E5%8F%96%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/11/网络安全之数据包截取原理/</id>
    <published>2018-04-11T03:29:22.000Z</published>
    <updated>2018-04-11T05:04:05.370Z</updated>
    
    <content type="html"><![CDATA[<p>今年不像个前端，更像个杂牌军，什么都学，什么都想学，并且突然学上了网络安全，简单描述一下数据包截获的原理</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=420401412&auto=0&height=66"></iframe><br><a id="more"></a><br>废话不多说，我写步骤，你们看就懂了，很简单的原理。<br>这里我做个试验，就是用虚拟机建了四台PC，分别是VM0,VM1,VM2,VM3。<br>配置分别是<br>VM0：ip：192.168.200.10（作为截取数据包用的机器）<br>VM1：ip：192.168.200.1<br>VM2：配了两个网卡，网卡1:192.168.100.2，网卡2:192.168.200.2<br>VM3：ip：192.168.200.3（作为WEB Server和FTP Server）</p><p>分别放在LAN1区段，LAN2区段<br>保证VM2能ping通VM3</p><h3 id="开始步骤"><a href="#开始步骤" class="headerlink" title="开始步骤"></a>开始步骤</h3><p>一、<br>Vm3–web服务<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websav/1.png" alt="“装iis并设置访问地址为VM3的ip”" title="">                </div>                <div class="image-caption">“装iis并设置访问地址为VM3的ip”</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websav/2.png" alt="“VM2的浏览器能通过VM3的IP访问VM3的网站”" title="">                </div>                <div class="image-caption">“VM2的浏览器能通过VM3的IP访问VM3的网站”</div>            </figure><br>二、<br>Vm3–FTP服务<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websav/3.png" alt="“装FTP服务”" title="">                </div>                <div class="image-caption">“装FTP服务”</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websav/4.png" alt="“设置登录密码”" title="">                </div>                <div class="image-caption">“设置登录密码”</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websav/5.png" alt="“FTP管理员登录”" title="">                </div>                <div class="image-caption">“FTP管理员登录”</div>            </figure><br>三、<br>开始用VM0截取VM2访问VM3的数据<br>（1）为了可以把抓包工具直接拖到虚拟机，先在vm0上安装VMware Toos<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websav/6.png" alt="“FTP管理员登录”" title="">                </div>                <div class="image-caption">“FTP管理员登录”</div>            </figure><br>打开抓包工具设置截取的协议以及地址之后开始抓包，然后用VM2访问VM3的网站<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websav/7.png" alt="“截取到的数据”" title="">                </div>                <div class="image-caption">“截取到的数据”</div>            </figure><br>同样的方式，打开抓包工具之后，VM2登录FTP，就截获了VM3的管理员以及密码（划线部分）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/websav/8.png" alt="“截取到的FTP数据”" title="">                </div>                <div class="image-caption">“截取到的FTP数据”</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年不像个前端，更像个杂牌军，什么都学，什么都想学，并且突然学上了网络安全，简单描述一下数据包截获的原理&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=420401412&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="截取数据包原理" scheme="http://yoursite.com/tags/%E6%88%AA%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>git版本更新</title>
    <link href="http://yoursite.com/2018/03/11/git%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2018/03/11/git版本更新/</id>
    <published>2018-03-10T18:02:55.000Z</published>
    <updated>2018-03-12T00:24:04.138Z</updated>
    
    <content type="html"><![CDATA[<p>今晚在推送项目的时候遇到了Git推送失败：HttpRequestException</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=408280692&auto=0&height=66"></iframe><br><a id="more"></a><br>推送失败有可能不是项目本身的问题，因为本地开启服务器能正常跑起来，提示说是用户名找不到，原因是<a href="https://githubengineering.com/crypto-removal-notice/" target="_blank" rel="external">这是我查到的资料</a><br>可以从<a href="https://git-scm.com/" target="_blank" rel="external">下载</a>并重新安装Git的最新源代码版本。我自己是windows，所以下载适用于Windows的Git的最新（2.16.2）。这是最近维护的版本。它于18日前在2018-02-20发布，会同时更新Git Credential Manager。<br>下载安装完成之后（步骤无脑next也可以）<br>查看是否更新成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//查看Git版本的命令</div><div class="line">git --version</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/gitupdate/git.JPG" alt="“查看结果”" title="">                </div>                <div class="image-caption">“查看结果”</div>            </figure><p>这样git版本就更新完成了</p><h3 id="远程免密推送"><a href="#远程免密推送" class="headerlink" title="远程免密推送"></a>远程免密推送</h3><p>因为远程的代码管理是基于SSH的，Git则需要配置SSH。<br>1 、设置Git的user name和email<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"xxxx"</span>  //这里是用户名</div><div class="line">$ git config --global user.email <span class="string">"xx@xxx"</span>  //这里是邮箱</div></pre></td></tr></table></figure></p><p>2、配置SSH密钥：<br>1）查看是否生成过ssh秘钥，路径是c盘下面的.ssh文件夹（没有说明没生成过秘钥）,有的话备份再删除因为一会会生成新的<br>2）生成密钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C “xxx@xx”</div></pre></td></tr></table></figure></p><p>按回车，得到id_rsa和id_rsa.pub（这两文件是生成在.ssh里头的）<br>4）登录github添加“id_rsa.pub”里面的公钥。<br>5）测试：ssh git@github.com<br>到这里如果成功的话，就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚在推送项目的时候遇到了Git推送失败：HttpRequestException&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=408280692&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Git更新" scheme="http://yoursite.com/tags/Git%E6%9B%B4%E6%96%B0/"/>
    
      <category term="Git推送失败" scheme="http://yoursite.com/tags/Git%E6%8E%A8%E9%80%81%E5%A4%B1%E8%B4%A5/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0我踩过的坑，希望你别踩</title>
    <link href="http://yoursite.com/2018/03/10/vue2-0%E6%88%91%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%8C%E5%B8%8C%E6%9C%9B%E4%BD%A0%E5%88%AB%E8%B8%A9/"/>
    <id>http://yoursite.com/2018/03/10/vue2-0我踩过的坑，希望你别踩/</id>
    <published>2018-03-10T10:01:12.000Z</published>
    <updated>2018-03-10T18:05:26.549Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个伤心的故事，vue2.0做1.0的东西踩过的坑…</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5273093&auto=0&height=66"></iframe><br><a id="more"></a></p><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p>（还有许多依赖包也是如此比如css-loader等）<br>这东西在1.0的时候只需要在package.json里面声明一下然后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure></p><p>express的依赖就安装完毕了，但是在2.0这样玩的时候报出express is not defind<br>解决方案就是安装一下express，安装命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install express --save</div></pre></td></tr></table></figure></p><p>假如是暂时安装而不将其添加到依赖项列表中，则忽略–save，安装完之后直接跑起来如果还是报错，到依赖包package.json里面定义一下，然后npm install，<br>webpack配置文件再定义一下，就可以跑了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var express = require(<span class="string">'express'</span>);</div></pre></td></tr></table></figure></p><p>。。。也许你都装了那些配置，然后只是忘了var express = require(‘express’）,非常尴尬的说我就是如此hhhhh，装完一切才发现我是没var就用，这个例子很简单，但是2.0的很多依赖都是这么整的，所以碰到坑的时候不妨一试</p><h3 id="vue路由（vue-router）"><a href="#vue路由（vue-router）" class="headerlink" title="vue路由（vue-router）"></a>vue路由（vue-router）</h3><p>在用脚手架构建项目的时候会提示时候安装vue-router，如果选了它就直接帮忙安装好，路由的东西写在脚手架生成的router文件下的index.js下面，假如选择了否之后，就需要自己装路由<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vue-router</div></pre></td></tr></table></figure></p><p>package.json里（dependencies）加上”vue-router”: “^0.7.13（这个版本号是看你自己要装什么版本）”</p><p>它的坑：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cannot <span class="built_in">read</span> property <span class="string">'component'</span> of undefined</div></pre></td></tr></table></figure></p><p>解决方案：<br>1.打开package.json将”dependencies”中的   “vue-router”版本改为：”^2.2.0”<br>2.npm install<br>3.在App.vue中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">将</div><div class="line">&lt;a v-link=<span class="string">"&#123;path:'/xxx'&#125;"</span>&gt;xxx&lt;/a&gt;</div><div class="line">改成</div><div class="line">&lt;router-link to=<span class="string">"/xxx"</span>&gt;xxx&lt;/router-link&gt;</div></pre></td></tr></table></figure></p><p>4.然后在main.js中import<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import VueRouter from <span class="string">'vue-router'</span>;</div></pre></td></tr></table></figure></p><p>否则如图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vue2.0keng/1.gif" alt="“。。。”" title="">                </div>                <div class="image-caption">“。。。”</div>            </figure><br>使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//定义路由</div><div class="line">var routes=[</div><div class="line">&#123;path:<span class="string">'/'</span>,redirect: <span class="string">'/xxx'</span>&#125;, </div><div class="line">&#123;path:<span class="string">'/xxx'</span>,component:xxx&#125;,</div><div class="line">&#123;path:<span class="string">'/yyy'</span>,component:yyy&#125;,</div><div class="line">&#123;path:<span class="string">'/zzz'</span>,component:zzz&#125;</div><div class="line">]</div><div class="line">//创建 router 实例，然后传 `routes` 配置</div><div class="line">var router=new VueRouter(&#123;</div><div class="line">linkActiveClass: <span class="string">'active'</span>,</div><div class="line">  routes</div><div class="line">&#125;);</div><div class="line">//=&gt;是ES6的箭头语法</div><div class="line">new Vue(&#123;</div><div class="line">el:<span class="string">'#app'</span>,</div><div class="line">router,</div><div class="line">render:h=&gt;h(App)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="处理前后端数据交互vue–resource"><a href="#处理前后端数据交互vue–resource" class="headerlink" title="处理前后端数据交互vue–resource"></a>处理前后端数据交互vue–resource</h3><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vue-resource</div></pre></td></tr></table></figure></p><p>交互也可以用axios</p><h3 id="better-scroll操作dom的时候的坑"><a href="#better-scroll操作dom的时候的坑" class="headerlink" title="better-scroll操作dom的时候的坑"></a>better-scroll操作dom的时候的坑</h3><p>这里先装一下better-scroll<br>1、package.json写上”better-scroll”: “^1.8.1”<br>2、执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure></p><p>（用这个的时候的坑）<br>在vue1.0的时候两个外部dom获取写成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;div class=<span class="string">"menu-wrapper"</span> v-el:menu-wrapper&gt;</div><div class="line">&lt;div class=<span class="string">"foods-wrapper"</span> v-el:foods-wrapper&gt;、</div><div class="line"></div><div class="line">//挂载到els的时候</div><div class="line">this.meunScroll = new BScroll(this.<span class="variable">$els</span>.menuWrapper, &#123;&#125;);</div><div class="line">this.foodsScroll = new BScroll(this.<span class="variable">$els</span>.foodsWrapper, &#123;&#125;);</div><div class="line"><span class="function"><span class="title">created</span></span>() &#123;</div><div class="line">      this.<span class="variable">$http</span>.get(<span class="string">'/api/goods'</span>).<span class="keyword">then</span>((response) =&gt; &#123;</div><div class="line">        response = response.body;</div><div class="line">        <span class="keyword">if</span> (response.errno === ERR_OK) &#123;</div><div class="line">          this.goods = response.data;</div><div class="line">          this.<span class="variable">$nextTick</span>(() =&gt; &#123;</div><div class="line">            this._initScroll();</div><div class="line">            this._calculateHeight();</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;,</div><div class="line">methods: &#123;</div><div class="line">      <span class="function"><span class="title">_initScroll</span></span>() &#123;</div><div class="line">        this.meunScroll = new BScroll(this.<span class="variable">$els</span>.menuWrapper, &#123;&#125;);</div><div class="line">        this.foodsScroll = new BScroll(this.<span class="variable">$els</span>.foodsWrapper, &#123;&#125;);</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在1.0里面这样写没问题，但是到了2.0版本就爆炸了，所以在2.0里面要换一种写法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//两个外部dom获取写成ref</div><div class="line">&lt;div class=<span class="string">"menu-wrapper"</span> ref=<span class="string">"menuWrapper"</span>&gt;</div><div class="line">&lt;div class=<span class="string">"foods-wrapper"</span> ref=<span class="string">"foodsWrapper"</span>&gt;</div><div class="line"></div><div class="line">//挂载的时候挂在到refs</div><div class="line"><span class="function"><span class="title">created</span></span>() &#123;</div><div class="line">      this.<span class="variable">$http</span>.get(<span class="string">'/api/goods'</span>).<span class="keyword">then</span>((response) =&gt; &#123;</div><div class="line">        response = response.body</div><div class="line">        <span class="keyword">if</span> (response.errno === ERR_OK) &#123;</div><div class="line">          this.goods = response.data</div><div class="line">          this.<span class="variable">$nextTick</span>(() =&gt; &#123;</div><div class="line">            this._initScroll()</div><div class="line">          &#125;)</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;,</div><div class="line">methods: &#123;</div><div class="line">      <span class="function"><span class="title">_initScroll</span></span>() &#123;</div><div class="line">        this.meunScroll = new BScroll(this.<span class="variable">$refs</span>.menuWrapper, &#123;&#125;)</div><div class="line">        this.foodsScroll = new BScroll(this.<span class="variable">$refs</span>.foodsWrapper, &#123;&#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="$dispatch"></a>$dispatch</h3><p>这个的坑比较简单，因为在2.0版本的时候这东西被废弃了，用它肯定Uncaught TypeError: this.$dispatch is not a function啊<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vue2.0keng/1.JPG" alt="“你好，我叫报错”" title="">                </div>                <div class="image-caption">“你好，我叫报错”</div>            </figure><br>这是因为在vue2.0的时候$dispatch和$broadcast已经被弃用了<br>解决方案：<br>可以改成用#$emit方法，$on也可以试试</p><h3 id="props的问题"><a href="#props的问题" class="headerlink" title="props的问题"></a>props的问题</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vue2.0keng/2.JPG" alt="“你好，我叫props的问题”" title="">                </div>                <div class="image-caption">“你好，我叫props的问题”</div>            </figure><p>解决方案：<br>在Vue2中组件的props的数据流动改为了只能单向流动，即只能由组件外（调用组件方）通过组件的DOM属性attribute传递props给组件内，组件内只能被动接收组件外传递过来的数据，不能修改由外层传来的props数据。可以把product-list.vue中的products放到data中。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/vue2.0keng/3.JPG" alt="“你好，我叫弄好了”" title="">                </div>                <div class="image-caption">“你好，我叫弄好了”</div>            </figure><br>另外Vue1.0中可以使用的双向props，2.0中不再支持双向props，且规定组件自身修改props是反模式的。可以使用computed和data来代替props的操作。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>切换组件时，组件当前的状态能被保留，vue.js给我们提供了一个非常方便的api，组件状态保留功能<br>用法：在APP.vue路由标签加上keep-alive<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;router-view :seller=<span class="string">"seller"</span> keep-alive&gt;&lt;/router-view&gt;</div></pre></td></tr></table></figure></p><p>当然这是vue1.0版本的用法，vue2.0提供了一个keep-alive组件用来缓存组件,避免多次加载相应的组件,减少性能消耗<br>用法（同APP.vue）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  &lt;!--组件缓存--&gt;</div><div class="line">&lt;keep-alive&gt;</div><div class="line"></div><div class="line">&lt;component&gt;</div><div class="line">  &lt;!-- 组件将被缓存 --&gt;</div><div class="line">&lt;/component&gt;</div><div class="line">&lt;/keep-alive&gt;</div><div class="line">有时候可能需要缓存整个站点的所有页面,而页面一般一进去都要触发请求的</div><div class="line">在使用keep-alive的情况下</div><div class="line">&lt;keep-alive&gt;</div><div class="line">    &lt;router-view :seller=<span class="string">"seller"</span> keep-alive&gt;&lt;/router-view&gt;</div><div class="line">&lt;/keep-alive&gt;</div></pre></td></tr></table></figure></p><p>2.0中的transition用法也有所改变不再是以前写在标签内，而是用transition组件包住需要写动画的地方<br>具体可以瞄一眼api</p><p>来一个题外话<br>1W是多少度电？？（这和it木有关系，只因我比较喜欢养鱼，因为仔细观察鱼很神奇）<br>这个问题相信很多喜欢养鱼的朋友都在想，毕竟增氧泵24小时都在工作，担心耗电的话来算一算，度是用电器耗电量的单位千瓦时,1度=1千瓦时,1W的电器工作1000小时耗1度电,1000瓦的用电器工作1小时耗1度电,500瓦的用电器工作2小时耗1度电。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个伤心的故事，vue2.0做1.0的东西踩过的坑…&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=5273093&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="vue-router" scheme="http://yoursite.com/tags/vue-router/"/>
    
      <category term="props" scheme="http://yoursite.com/tags/props/"/>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="vue--resource" scheme="http://yoursite.com/tags/vue-resource/"/>
    
      <category term="better-scroll" scheme="http://yoursite.com/tags/better-scroll/"/>
    
      <category term="2.0弃用的方法" scheme="http://yoursite.com/tags/2-0%E5%BC%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
      <category term="组件状态保留" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E4%BF%9D%E7%95%99/"/>
    
  </entry>
  
  <entry>
    <title>npm install的一个小坑</title>
    <link href="http://yoursite.com/2018/02/21/npm-install%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/"/>
    <id>http://yoursite.com/2018/02/21/npm-install的一个小坑/</id>
    <published>2018-02-21T15:53:25.000Z</published>
    <updated>2018-07-05T15:30:26.456Z</updated>
    
    <content type="html"><![CDATA[<p>今晚跑一个vue项目，碰到的一个小坑。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=165347&auto=0&height=66"></iframe><br><a id="more"></a><br>假设你美滋滋install一个vue项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">npm install -g vue-cli</div><div class="line"></div><div class="line">vue init webpack yourproject</div><div class="line">...</div></pre></td></tr></table></figure></p><p>这些都木有问题，接下来到npm install的时候，突然biu出来几个大写红色的ERR！，like this<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/npmInstall/npmbug1.JPG" alt="“大写红色的ERR！”" title="">                </div>                <div class="image-caption">“大写红色的ERR！”</div>            </figure><br>那么这下或许懵逼了，可能你以为直接跑项目无视掉就好，然后就<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run dev</div></pre></td></tr></table></figure></p><p>这下更厉害了，满屏幕大写红色的ERR！<br>要是可视化还好，一堆字母在这看着确实不舒服。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、跑一下这个<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm cache clean --force</div></pre></td></tr></table></figure></p><p>2、或者跑一下这个<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/npmInstall/npmbug2.JPG" alt="“项目就好好跑起来了”" title="">                </div>                <div class="image-caption">“项目就好好跑起来了”</div>            </figure><p>好了。。继续苦逼的研究=  =</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚跑一个vue项目，碰到的一个小坑。&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=165347&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="npm install" scheme="http://yoursite.com/tags/npm-install/"/>
    
      <category term="vue安装" scheme="http://yoursite.com/tags/vue%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>IE/chrome/Firefox的鼠标滚轮兼容</title>
    <link href="http://yoursite.com/2018/02/05/IE-chrome-Firefox%E7%9A%84%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E5%85%BC%E5%AE%B9/"/>
    <id>http://yoursite.com/2018/02/05/IE-chrome-Firefox的鼠标滚轮兼容/</id>
    <published>2018-02-05T07:11:25.000Z</published>
    <updated>2018-02-10T02:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个鼠标滚轮滚动事件的小兼容，瞄一眼或许有用<br><a id="more"></a></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=485687056&auto=0&height=66"></iframe><br>在开发中会经常遇到一种需求，就是滚动滚动鼠标滚轮改变购买价格，数量，内容等等，这里说一下滚轮的小坑</p><h3 id="滚轮事件分成ie、chrome、Firefox"><a href="#滚轮事件分成ie、chrome、Firefox" class="headerlink" title="滚轮事件分成ie、chrome、Firefox"></a>滚轮事件分成ie、chrome、Firefox</h3><p>IE/chrome：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">obj.onmousewheel=<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    alert(88888888);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Firefox:火狐没有onmousewheel事件（写了会报错），所以火狐用DOMMouseScroll，并且必须用addEventListener绑定否则IE下会报错，因此可以写个判断<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (obj.addEventListener) &#123;//如果有该方法</div><div class="line">    obj.addEventListener(<span class="string">'DOMMouseScroll'</span>,func,<span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</div><div class="line">alert(88888888);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>解决了绑定事件触发的问题，然后就是判断滚轮方向，判断滚轮方向也分成ie/chrome和Firefox</p><h3 id="兼所有浏览器的鼠标滚轮，判断上下："><a href="#兼所有浏览器的鼠标滚轮，判断上下：" class="headerlink" title="兼所有浏览器的鼠标滚轮，判断上下："></a>兼所有浏览器的鼠标滚轮，判断上下：</h3><p>ie/chrome:event.wheelDelta<br>Firefox：event.detail</p><p>event.wheelDelta和event.detail是两个数字类型的值，ie/chrome滚轮往上是正数，往下是负数，Firefox相反，所以根据这个可以写兼容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//兼容上下滚轮的方法</div><div class="line"><span class="keyword">function</span> func(ev)&#123;</div><div class="line">    var h=<span class="literal">true</span>;</div><div class="line">    var ev=ev||event;</div><div class="line">    <span class="keyword">if</span> (ev.wheelDelta) &#123;</div><div class="line">        h=ev.wheelDelta&gt;0?<span class="literal">true</span>:<span class="literal">false</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        h=ev.detail&gt;0?<span class="literal">false</span>:<span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (h) &#123;</div><div class="line">        obj.style.属性=滚轮往上做的事;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        obj.style.属性=滚轮往下做的事;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="解决滚动条出现，鼠标滚轮失效问题"><a href="#解决滚动条出现，鼠标滚轮失效问题" class="headerlink" title="解决滚动条出现，鼠标滚轮失效问题"></a>解决滚动条出现，鼠标滚轮失效问题</h3><p>这里还有个问题，假如我给页面高度3000，触发浏览器的滚动条，滚轮失效<br>原因：事件默认行为<br>解决：阻止默认行为的发生<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div></pre></td></tr></table></figure></p><p>ie/chrome下问题解决，Firefox问题没解决<br>原因：return false阻止的是on事件触发的默认行为，Firefox是通过addEventListener绑定的事件处理函数，所以需要通过event下面的preventDefault()阻止。<br>写法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ev.preventDefault) &#123;</div><div class="line">    ev.preventDefault();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ie/chrome和Firefox同时可以解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ev.preventDefault) &#123;</div><div class="line">    ev.preventDefault();</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> <span class="literal">false</span>;</div></pre></td></tr></table></figure></p><h3 id="事件阻止是根据事件绑定进行阻止"><a href="#事件阻止是根据事件绑定进行阻止" class="headerlink" title="事件阻止是根据事件绑定进行阻止"></a>事件阻止是根据事件绑定进行阻止</h3><p>例如分别用on和addEventListener禁掉鼠标右键点击文档出现小菜单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">document.oncontextmenu=<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">//禁掉了</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">document.addEventListener(<span class="string">'contextmenu'</span>,<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">&#125;)</div><div class="line">//没禁掉</div></pre></td></tr></table></figure><p>原因：禁掉addEventListener应该用preventDefault();<br>写法：</p><pre><code class="bash">document.addEventListener(<span class="string">'contextmenu'</span>,<span class="keyword">function</span>(ev){    var ev=ev||event;    ev.preventDefault();})// 禁掉了</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个鼠标滚轮滚动事件的小兼容，瞄一眼或许有用&lt;br&gt;
    
    </summary>
    
    
      <category term="IE-chrome-Firefox兼容" scheme="http://yoursite.com/tags/IE-chrome-Firefox%E5%85%BC%E5%AE%B9/"/>
    
      <category term="鼠标滚轮兼容" scheme="http://yoursite.com/tags/%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>js中的事件冒泡</title>
    <link href="http://yoursite.com/2018/02/02/js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"/>
    <id>http://yoursite.com/2018/02/02/js中的事件冒泡/</id>
    <published>2018-02-02T09:02:50.000Z</published>
    <updated>2018-02-10T02:19:44.191Z</updated>
    
    <content type="html"><![CDATA[<p>事件是javascript中的核心内容之一，在对事件的应用中不可避免的要涉及到一个重要的概念，那就是事件冒泡，在了解事件冒泡之前，先了解一下事件流<br><a id="more"></a></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=496040491&auto=0&height=66"></iframe></p><h3 id="什么是事件流："><a href="#什么是事件流：" class="headerlink" title="什么是事件流："></a>什么是事件流：</h3><p>从window到document到h1、p、h2、form…等。也就是html元素触发事件，那么这个事件就会在DOM中的触发节点和根节点之间按照一定的顺序传播，所有经过的节点都会接收到被触发的事件，这个传播过程被称之为事件流。</p><h3 id="什么是事件冒泡："><a href="#什么是事件冒泡：" class="headerlink" title="什么是事件冒泡："></a>什么是事件冒泡：</h3><p>就是当一个元素触发一个事件，事件会像是水泡一样，从触发元素向它的所有父节点传播，一直到根节点都会接收到此事件，如果父元素中注册了相应的事件处理函数，那么尽管事件在子节点触发的，在父元素上注册的事件处理函数同样会被触发。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/maopaoImg/maopao.jpg" alt="“冒泡大哥”" title="">                </div>                <div class="image-caption">“冒泡大哥”</div>            </figure><br>例如:我创建了三个div，给最里头的div加上点击事件（准确的说是给元素加上事件处理函数）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/maopaoImg/1.JPG" alt="“html代码”" title="">                </div>                <div class="image-caption">“html代码”</div>            </figure><br>预览效果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/maopaoImg/2.JPG" alt="“预览效果”" title="">                </div>                <div class="image-caption">“预览效果”</div>            </figure><br>里头的div分别绑定了click事件，然后点击最里头的div3，就会依次弹出div3,div2,div1，这就是事件冒泡，原理是当div3执行完事件处理函数之后，事件就会向父级传播，像冒泡一样所以叫事件冒泡。</p><p>假设把div2的事件注释掉<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// dIv2.addEventListener(<span class="string">'click'</span>,fn);</div></pre></td></tr></table></figure></p><p>依然可以弹出div1和div3,事实上div2身上也接收到了默认冒泡事件，只是没有给它事件处理函数，也就是没有告诉它接收到事件之后做什么，所以即使父级不绑定执行的函数，冒泡也默认存在，这就是默认存在的事件冒泡机制。</p><h3 id="事件冒泡的影响："><a href="#事件冒泡的影响：" class="headerlink" title="事件冒泡的影响："></a>事件冒泡的影响：</h3><p>直接举个例子：比如下拉菜单（此处有点丑）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/maopaoImg/3.JPG" alt="“html代码”" title="">                </div>                <div class="image-caption">“html代码”</div>            </figure><br>效果图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/maopaoImg/4.JPG" alt="“预览效果”" title="">                </div>                <div class="image-caption">“预览效果”</div>            </figure><br>需求是点击按钮菜单显示，点击文档区域菜单隐藏，js代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var oBtn=document.getElementById(<span class="string">"btn"</span>);</div><div class="line">var dIv=document.getElementById(<span class="string">"div"</span>);</div><div class="line"></div><div class="line">oBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">dIv.style.display=<span class="string">"block"</span>;</div><div class="line">&#125;);</div><div class="line">document.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">dIv.style.display=<span class="string">"none"</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>那么问题来了，文档还没加上点击事件的时候，按钮点击菜单可以显示，文档加上点击事件之后，按钮点击就点不出菜单了。</p><p>这时候给文档点击加上延时执行定时器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">document.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        dIv.style.display=<span class="string">"none"</span>;</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>这时候就可以正常点击。</p><p>原理：按钮的点击事件点击之后将事件传递到了document父级，所以按钮点击完成之后由于document也绑定了事件处理函数“菜单隐藏”，所以就直接执行了。</p><h3 id="阻止冒泡："><a href="#阻止冒泡：" class="headerlink" title="阻止冒泡："></a>阻止冒泡：</h3><p>如果在某个地方不想让事件冒泡可以单独阻止，毕竟冒泡事件带来的好处也很大，比如直接触发文档流下的许多元素绑定的事件处理函数</p><h3 id="阻止冒泡的方法：在当前要阻止的事件冒泡函数中调用event-cancelBubble-true"><a href="#阻止冒泡的方法：在当前要阻止的事件冒泡函数中调用event-cancelBubble-true" class="headerlink" title="阻止冒泡的方法：在当前要阻止的事件冒泡函数中调用event.cancelBubble=true;"></a>阻止冒泡的方法：在当前要阻止的事件冒泡函数中调用event.cancelBubble=true;</h3><p>例如将上面的js修改为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">oBtn.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span>(ev)&#123;</div><div class="line">    var ev=ev||event;</div><div class="line">    ev.cancelBubble=<span class="literal">true</span>;//阻止当前对象的当前事件的冒泡</div><div class="line">    dIv.style.display=<span class="string">"block"</span>;</div><div class="line">&#125;);</div><div class="line">document.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    dIv.style.display=<span class="string">"none"</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>下拉菜单就可以正常跑起来了（虽丑），那么问题又来了，假如按钮身上同时还绑定了一个mouseover的事件，上面设置的阻止冒泡就不生效了，这时候也需要给mouseover事件阻止冒泡，也就是冒泡只能单独阻止。</p><h3 id="事件冒泡的用法："><a href="#事件冒泡的用法：" class="headerlink" title="事件冒泡的用法："></a>事件冒泡的用法：</h3><p>也直接举例子，比如分享功能：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/maopaoImg/6.JPG" alt="“html代码”" title="">                </div>                <div class="image-caption">“html代码”</div>            </figure><br>效果图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/maopaoImg/6.JPG" alt="“预览效果”" title="">                </div>                <div class="image-caption">“预览效果”</div>            </figure><br>需求：鼠标经过的时候从左边出来，鼠标离开的时候只显示分享到部分，传统的做法是分别加上mouseover、mouseout,<br>但是用冒泡的做法是直接给div去做就行了：</p><p>js代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var oDiv=document.getElementById(<span class="string">"div1"</span>);</div><div class="line">oDiv.addEventListener(<span class="string">'mouseover'</span>, <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    this.style.left=<span class="string">"0px"</span>;</div><div class="line">&#125;);</div><div class="line">oDiv.addEventListener(<span class="string">'mouseout'</span>, <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    this.style.left=<span class="string">"-100px"</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>当然，阻止事件冒泡的方法还有两种：</p><h3 id="另外两种阻止事件冒泡的方法和用法"><a href="#另外两种阻止事件冒泡的方法和用法" class="headerlink" title="另外两种阻止事件冒泡的方法和用法"></a>另外两种阻止事件冒泡的方法和用法</h3><p>方法一：event.stopPropagation();<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"xxx"</span>).click(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    event.stopPropagation();</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>方法二：event.target<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    $(<span class="string">"#xxx"</span>).click(<span class="keyword">function</span>(event)&#123;</div><div class="line">        <span class="keyword">if</span>(event.target==this)&#123;</div><div class="line">            $(<span class="string">"#xxx"</span>).xxx</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>顺便介绍一下event对象</p><h3 id="Event对象"><a href="#Event对象" class="headerlink" title="Event对象"></a>Event对象</h3><p>当一个事件发生的时候，和当前这个对象发生的这个事件有关的一些详细的信息都会被临时保存到一个指定地方—event对象，供需要的时候调用<br>用来获取事件的详细信息。</p><h3 id="Event对象的兼容："><a href="#Event对象的兼容：" class="headerlink" title="Event对象的兼容："></a>Event对象的兼容：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ev=ev||window.event</div></pre></td></tr></table></figure><h3 id="Event对象下获取鼠标位置："><a href="#Event对象下获取鼠标位置：" class="headerlink" title="Event对象下获取鼠标位置："></a>Event对象下获取鼠标位置：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clientX clientY</div></pre></td></tr></table></figure><p>事件对象必须在一个事件调用的函数里面使用才有内容</p><h3 id="事件函数"><a href="#事件函数" class="headerlink" title="事件函数"></a>事件函数</h3><p>事件调用的函数，取决于被什么时间调用</p><h3 id="IE、谷歌和火狐下的ev"><a href="#IE、谷歌和火狐下的ev" class="headerlink" title="IE、谷歌和火狐下的ev"></a>IE、谷歌和火狐下的ev</h3><p>iE/chrome:event是一个内置全局对象<br>Firefox（同时也是标准下）:事件对象是通过事件函数的第一个参数传入如function fn(ev)====（如果一个函数是被事件调用的，那么这个函数定义的第一个参数就是事件对象）</p><h3 id="ev用的时候-兼容处理-："><a href="#ev用的时候-兼容处理-：" class="headerlink" title="ev用的时候(兼容处理)："></a>ev用的时候(兼容处理)：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var ev=ev||evnt</div></pre></td></tr></table></figure><h3 id="查看事件："><a href="#查看事件：" class="headerlink" title="查看事件："></a>查看事件：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(attr <span class="keyword">in</span> ev)&#123;</div><div class="line">    console.log(attr+<span class="string">"="</span>+ev[attr])</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="同时联想到一些可能用得上的事件，算了也写在这里吧："><a href="#同时联想到一些可能用得上的事件，算了也写在这里吧：" class="headerlink" title="同时联想到一些可能用得上的事件，算了也写在这里吧："></a>同时联想到一些可能用得上的事件，算了也写在这里吧：</h3><p>onscroll:当滚动条滚动的时候触发<br>onresize:当窗口大小发生改变的时候触发<br>onfocus:获取焦点事件<br>onblur:失去焦点事件<br>focus()：页面打开给指定元素设置焦点…txt.focus();<br>blur()取消指定元素的焦点<br>select()选择指定元素的文本内容(只能操作可交互性的文本内容)</p><h3 id="最后再来一个判断是否IE浏览器的方法"><a href="#最后再来一个判断是否IE浏览器的方法" class="headerlink" title="最后再来一个判断是否IE浏览器的方法"></a>最后再来一个判断是否IE浏览器的方法</h3><p>js查看浏览器信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(window.navigator.userAgent);</div></pre></td></tr></table></figure></p><p>验证IE<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(window.navigator.userAgent.indexOf(<span class="string">'MSIE'</span>)!=-1)&#123;</div><div class="line">       alert(<span class="string">"IE"</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">       alert(<span class="string">"不是IE"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那既然写了事件，就多写一些吧（其实这里是因为在这地方突然没网，线上更新不了，用手机开热点手机坏了（已扔下一楼），然后这里顺便扯一些其他的东西）</p><h3 id="绑定多个事件"><a href="#绑定多个事件" class="headerlink" title="绑定多个事件"></a>绑定多个事件</h3><p>如果多个部门或者多个人都需要对同一个元素绑定事件<br>A部门绑定click事件A，B部门绑定click事件B，一般如果写成onclick的话，一点击就会覆盖掉另一个部门的东西，解决方案：<br>1、部门之间开发的时候密切沟通好里头的各种命名以及结构数据等，然后将两个事件合并，那么好，两个部门同时的话，两个部门一起交流沟通，好，这时候如果每个部门的需求是每部门再来个事件，行，那就沟通呗，一个星期达成共识，如果需求里头代码多，变量多，那继续沟通呗，好，老板这时候或许已经在想宣告破产之后的情景了。<br>2、绑定多个事件用addEventListener（事件，函数处理方法，true或者false（代表捕获与不捕获）），IE下是attachEvent（on+事件，函数处理方法）</p><h3 id="那么什么是事件捕获："><a href="#那么什么是事件捕获：" class="headerlink" title="那么什么是事件捕获："></a>那么什么是事件捕获：</h3><p>捕获机制如果触发的话，事件会从父级元素经过，然后到触发的元素，和冒泡事件不同的是，冒泡是从触发的事件向父级传输</p><h3 id="call-方法"><a href="#call-方法" class="headerlink" title="call()方法"></a>call()方法</h3><p>attachEvent绑定的事件，this指向不会指向触发事件的元素，而是window,所以要用到call()方法，例如触发fn函数，写成fn.call();<br>call()方法里头的参数是触发的事件处理函数里头的this指向，如果是多个参数的函数例如fn(obj,attr)，就写成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fn.call(window,oDiv,class);</div></pre></td></tr></table></figure></p><p>这里第一个参数依旧是事件处理函数里头的this指向的window，后面两个参数是传给函数方法的参数。</p><h3 id="最后封一个绑定多个事件的方法，蛮实用"><a href="#最后封一个绑定多个事件的方法，蛮实用" class="headerlink" title="最后封一个绑定多个事件的方法，蛮实用"></a>最后封一个绑定多个事件的方法，蛮实用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="built_in">bind</span>(obj,eventName,fn)&#123;</div><div class="line">    <span class="keyword">if</span> (obj.addEventListener) &#123;</div><div class="line">        obj.addEventListener(eventName,fn,<span class="literal">false</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        obj.attachEvent(<span class="string">'on'</span>+eventName, <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">             fn.call(obj);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="事件绑定的取消"><a href="#事件绑定的取消" class="headerlink" title="事件绑定的取消"></a>事件绑定的取消</h3><p>1、事件绑定形式的取消<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">document.onclick=fun;</div><div class="line">document.onclick=null;</div></pre></td></tr></table></figure></p><p>2、通过addEventListener()取消<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IE下：obj.detachEvent(<span class="string">'onclick'</span>,fun)</div><div class="line">标准下：obj.removeEventListener(事件名称，事件处理函数，是否捕获)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件是javascript中的核心内容之一，在对事件的应用中不可避免的要涉及到一个重要的概念，那就是事件冒泡，在了解事件冒泡之前，先了解一下事件流&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="事件冒泡" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"/>
    
      <category term="event" scheme="http://yoursite.com/tags/event/"/>
    
      <category term="验证IE" scheme="http://yoursite.com/tags/%E9%AA%8C%E8%AF%81IE/"/>
    
      <category term="call()" scheme="http://yoursite.com/tags/call/"/>
    
      <category term="事件捕获" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7/"/>
    
  </entry>
  
  <entry>
    <title>post、get和ajax跨域</title>
    <link href="http://yoursite.com/2018/01/19/post%E3%80%81get%E5%92%8Cajax%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/01/19/post、get和ajax跨域/</id>
    <published>2018-01-18T16:00:01.000Z</published>
    <updated>2018-07-14T13:06:58.253Z</updated>
    
    <content type="html"><![CDATA[<p>做Web的需求一定会涉及到浏览器和服务器的交互，也就是B/S，B/S的交互又是通过HTTP协议，而post和get是HTTP协议中的两种方法。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=497047516&auto=0&height=66"></iframe><br><a id="more"></a></p><p>HTTP协议规定GET是获取资源的方法，POST是创建资源的方法，PUT是更新资源的方法，DELETE是删除资源的方法，PATCH是修改资源的方法。<br>一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。而GET一般用于获取/查询资源信息，POST一般用于更新资源信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/post_and_get/1.jpg" alt="“......”" title="">                </div>                <div class="image-caption">“......”</div>            </figure></p><h3 id="get相对post的优势是什么"><a href="#get相对post的优势是什么" class="headerlink" title="get相对post的优势是什么"></a>get相对post的优势是什么</h3><p>GET的所有信息都在URL，也就是地址栏，所以很方便的被记录下来，<br>请求中的URL可以被存在各种地方，甚至被搜索引擎收录<br>数据比POST透明化一点，“方便大家都看得到”。</p><h3 id="post和get的浏览器长度限制"><a href="#post和get的浏览器长度限制" class="headerlink" title="post和get的浏览器长度限制"></a>post和get的浏览器长度限制</h3><p>get<br>get是通过URL提交数据，因此get可提交的数据量就受url的最大长度限制，HTTP协议对URL长度是没有限制的，限制URL长度多是浏览器或者服务器的配置参数。<br>post<br>HTTP协议也没有对POST进行限制，一般是受服务器配置限制或者内存大小。PHP下可以修改的配置来设置POST的大小（最初默认是8M）。</p><h3 id="post和get的安全性"><a href="#post和get的安全性" class="headerlink" title="post和get的安全性"></a>post和get的安全性</h3><p>post和get都是明文传输<br>1.get是通过URL方式请求，可以直接看到，可能会保存在Web的日志中,也可能会保存在浏览器历史记录以及缓存中。<br>2.post是通过请求header请求，可以通过开发者工具或者抓包看到。<br>所以该https的时候还是得https</p><h3 id="get幂等，post不幂等"><a href="#get幂等，post不幂等" class="headerlink" title="get幂等，post不幂等"></a>get幂等，post不幂等</h3><p>幂等意味着对同一URL的多个请求应该返回同样的结果。。<br>1.按照RFC规范，PUT，DELETE和安全方法都是幂等的，但服务端实现是否幂等是无法确保的。<br>2.引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。<br>3.get请求用于信息获取，由于是安全且幂等的。一般不容易产生副作用。它仅仅是获取资源信息，不会影响资源的状态。</p><p>post不幂等，可能改变服务器上的资源的请求。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/post_and_get/3.jpg" alt="“......”" title="">                </div>                <div class="image-caption">“......”</div>            </figure></p><h3 id="用ajax时的get"><a href="#用ajax时的get" class="headerlink" title="用ajax时的get"></a>用ajax时的get</h3><p>get：<br>数据放在url<br>把数据名称和数据值用=连接，如果有多个的话，那么他会把多个数据组合用&amp;进行连接，然后把数据放到url?后面传到指定页面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'get.php?username=hhardyy&amp;sex=man'</span>,<span class="literal">true</span>);</div></pre></td></tr></table></figure></p><p>(具体数据根据后端给的接口拼接，因为不同的需求需要的数据不一样)</p><h3 id="后端php接收："><a href="#后端php接收：" class="headerlink" title="后端php接收："></a>后端php接收：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">header(<span class="string">'content-type:text/html;charset="utf-8"'</span>);</div><div class="line">error_reporting(0);</div><div class="line"><span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">'username'</span>];</div><div class="line"><span class="variable">$sex</span>=<span class="variable">$_GET</span>[<span class="string">'sex'</span>];</div><div class="line"><span class="built_in">echo</span> <span class="string">"你的名字:&#123;<span class="variable">$username</span>&#125;,性别:&#123;<span class="variable">$sex</span>&#125;"</span>;</div><div class="line">?&gt;</div></pre></td></tr></table></figure><p>此时如果将后端改成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"你好，你的名字:&#123;<span class="variable">$username</span>&#125;,性别:&#123;<span class="variable">$sex</span>&#125;"</span>;</div></pre></td></tr></table></figure><p>前端<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(xhr.responseText);</div></pre></td></tr></table></figure></p><p>弹出的依旧是：你的名字:hhardyy,性别:man”；而不会弹出你好,你的名字:hhardyy,性别:man</p><p>原因就是缓存的问题，重新提交一次数据，由于url地址一样，它会读出缓存里面的而不是读出服务器里面，</p><h3 id="get缓存问题解决方法："><a href="#get缓存问题解决方法：" class="headerlink" title="get缓存问题解决方法："></a>get缓存问题解决方法：</h3><p>在url?后面接上一个随机数或者时间戳，防止每次url一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'get.php?username=hhardyy&amp;sex=man&amp;'</span>+ new Date().getTime(),<span class="literal">true</span>);</div></pre></td></tr></table></figure></p><h3 id="get提交中文乱码解决办法："><a href="#get提交中文乱码解决办法：" class="headerlink" title="get提交中文乱码解决办法："></a>get提交中文乱码解决办法：</h3><p>编码encodeURI()<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'get.php?username='</span>+圳+<span class="string">'&amp;sex=man&amp;'</span>+ new Date().getTime(),<span class="literal">true</span>);/弹出中文乱码</div><div class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'get.php?username='</span>+encodeURI(<span class="string">'圳'</span>)+<span class="string">'&amp;sex=man&amp;'</span>+ new Date().getTime(),<span class="literal">true</span>);/正常</div></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/post_and_get/5.jpg" alt="“......”" title="">                </div>                <div class="image-caption">“......”</div>            </figure><h3 id="用ajax时的post"><a href="#用ajax时的post" class="headerlink" title="用ajax时的post"></a>用ajax时的post</h3><p>post：<br>数据放在send方法里面<br>enctype:提交的数据格式，默认application/x-www-form-urlencoded”application/x-www-form-urlencoded”&gt;<br>意思是根据url进行编码，也可以进行二进制编码等，后端拿到之后解码就可以拿到数据了</p><h3 id="后端php接收：-1"><a href="#后端php接收：-1" class="headerlink" title="后端php接收："></a>后端php接收：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">header(<span class="string">'content-type:text/html;charset="utf-8"'</span>);</div><div class="line">error_reporting(0);</div><div class="line"><span class="variable">$username</span>=<span class="variable">$_POST</span>[<span class="string">'username'</span>];</div><div class="line"><span class="variable">$sex</span>=<span class="variable">$_POST</span>[<span class="string">'sex'</span>];</div><div class="line"><span class="built_in">echo</span> <span class="string">"你的名字:&#123;<span class="variable">$username</span>&#125;,性别:&#123;<span class="variable">$sex</span>&#125;"</span>;</div><div class="line">?&gt;</div></pre></td></tr></table></figure><h3 id="前端数据提交："><a href="#前端数据提交：" class="headerlink" title="前端数据提交："></a>前端数据提交：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">xhr.open(<span class="string">'post'</span>,<span class="string">'post.php'</span>,<span class="literal">true</span>);</div><div class="line"></div><div class="line">xhr.setRequestHeader(<span class="string">'content-type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line">（声明发送的数据类型application/x-www-form-urlencoded）</div><div class="line">xhr.send(<span class="string">'username=hhardyy&amp;sex=18'</span>);</div></pre></td></tr></table></figure><p>post提交数据没有缓存问题</p><p>post中文编码没问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.send(<span class="string">'username=圳&amp;sex=18'</span>);</div></pre></td></tr></table></figure></p><p>因为已经声明了发送的数据类型urlencoded，所以它自动进行url编码。</p><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><p>“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），节省用户操作时间，提高用户体验，减少数据请求传输获取数据等等，比传统网页刷新需要整页刷新更帅一筹，比如注册页面，<br>传统网页需要填完所有信息然后点击注册按钮之后，填错的地方才给出警告，而ajax不同，可以在输入文本框，比如用户名的时候通过焦点事件向后台发送ajax异步请求，当你输入完用户名想输入密码的<br>时候，网页就会提示用户名是否已经被注册，或者合不合法，比传统填完一大串信息最后爆出一个符号错误又得回去修改整页的感觉nice好多。</p><h4 id="请求状态监控"><a href="#请求状态监控" class="headerlink" title="请求状态监控"></a>请求状态监控</h4><p>onreadystatechange（目前已经不推荐使用了，建议用load），理由呢，我写分别写出来，拿get来举例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> (xhr.readyState == 4) &#123;</div><div class="line"><span class="keyword">if</span> (xhr.status == 200) &#123;</div><div class="line">alert(xhr.responseText);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'url'</span>, <span class="literal">true</span>);</div><div class="line">xhr.send();</div><div class="line"></div><div class="line">各种请求状态的情况</div><div class="line">0（初始化）还没有调用open()方法</div><div class="line">1（载入）已调用send()方法，正在发送请求</div><div class="line">2（载入完成）send()方法完成，已收到全部响应内容</div><div class="line">3（解析）正在解析响应内容</div><div class="line">4（完成）响应内容解析完成，可以在客户端调用了</div></pre></td></tr></table></figure></p><p>load<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.onload = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">alert(xhr.responseText);</div><div class="line">&#125;</div><div class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'url'</span>, <span class="literal">true</span>);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure></p><p>responseText：返回以文本形式存放的内容<br>responseXML：返回XML形式的内容</p><h3 id="返回数据的处理"><a href="#返回数据的处理" class="headerlink" title="返回数据的处理"></a>返回数据的处理</h3><p>特别提醒一下，假如要解析JSON的时候需要注意，因为有Eval和JSON.parse两种方法将字符串解析成对象，两者的区别就是Eval属于饥不择食的那种，什么都转，所以不是特别安全，假如一些恶意代码什么的它也会正常解析，这就不太和谐了，所以一般推荐JSON.parse()来将字符串转成对象。</p><h4 id="eval与JSON-parse详解"><a href="#eval与JSON-parse详解" class="headerlink" title="eval与JSON.parse详解"></a>eval与JSON.parse详解</h4><p>eval:可以解析任何字符串变成js（缺点：什么都能解析，比如植入的一些病毒，木马什么的，它也会解析）<br>parse:只能解析json形式的字符串，json必须是严格模式的json，也就是key和value都要加引号（安全性高一些，对数据来说尽量用它）<br>另外还有个新东西stringify()<br>stringify(json)(将json转换成字符串，转成严格模式的字符串),也可以用于对对象的克隆和引用,就像这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a=&#123;</div><div class="line">    name:<span class="string">"hhardyy"</span></div><div class="line">&#125;</div><div class="line">var b=a;</div><div class="line">b.name=<span class="string">"xiaofangkuai"</span>；</div><div class="line">console.log（a.name）//xiaofangkuai</div></pre></td></tr></table></figure></p><p>很明显对象a的属性被影响了，用浅拷贝来解决问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a=&#123;</div><div class="line">    name:<span class="string">"hhardyy"</span></div><div class="line">&#125;</div><div class="line">var b=&#123;&#125;</div><div class="line"><span class="keyword">for</span>(var attr <span class="keyword">in</span> a)&#123;</div><div class="line">   b[attr]=a[attr];</div><div class="line">&#125;</div><div class="line">b.name=<span class="string">"xiaofangkuai"</span></div><div class="line">console.log（a.name）//hhardyy</div></pre></td></tr></table></figure></p><p>这样虽然，互不影响了但是这个只是浅拷贝，假如a的属性里面是多个json值就得用递归一层一层….显然不是特别厉害，厉害的解决方案是深拷贝，也就是新方法登场的时候<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a=&#123;</div><div class="line">    name:&#123;age:100&#125;</div><div class="line">&#125;;</div><div class="line">var str=JSON.stringify(a);</div><div class="line">var b=JSON.parse(str);</div><div class="line">b.name.age=200;</div><div class="line">console.log(a.name.age)//100</div></pre></td></tr></table></figure></p><p>但是IE6、7不兼容，兼容的方法也简单，勉强用evel或者去<a href="http://www.json.org/" target="_blank" rel="external">json的官网</a>下载json类下面的json2.js，然后引入,就可以兼容了</p><h3 id="跨域方案"><a href="#跨域方案" class="headerlink" title="跨域方案"></a>跨域方案</h3><p>既然ajax涉及了交互请求，那么就分成当前域名下和其他域名下，也就是请求地址，请求同一地址下面的数据，可以不用跨域，假设一个域名下的文件请求另外一个域名下的资源，就产生了跨域，提到跨域都会想到jsonp解决。</p><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><p>全称json padding，jsonp实现跨域的原理和script标签加载的差不多，用script标签加载资源是没有跨域问题的，在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数里面利用这个参数做一些事情，然后需要的时候通过script标签加载对应远程文件资源，当远程的文件资源被加载进来的时候，就会去执行我们前面定义好的函数，并且把数据当作这个函数的参数传入进去。<br>就是像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var oScript = document.createElement(<span class="string">'script'</span>);</div><div class="line">oScript.src = <span class="string">'getData.php'</span>;</div><div class="line">document.body.appendChild(oScript);</div></pre></td></tr></table></figure></p><p>可以利用这个原理将函数封装成按需加载的样子,然后写一个函数func(data)，就可以在func里头对数据data进行操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var oScript = document.createElement(<span class="string">'script'</span>);</div><div class="line">oScript.src = <span class="string">'getData.php?callback=func'</span>;</div><div class="line">document.body.appendChild(oScript);</div></pre></td></tr></table></figure></p><h3 id="更厉害的跨域方案"><a href="#更厉害的跨域方案" class="headerlink" title="更厉害的跨域方案"></a>更厉害的跨域方案</h3><p>就是后端的一些配合，在标准浏览器下，XMLHttpRequest对象已经是升级版本，支持了更多的特性，可以直接跨域了。前提是服务器端设置请求头，例如xxx.php中：header(“xxx:协议+域名”),既然提到了新特性，就要提到咱们的IE同志，因为IE如果想实现跨域请求，则需要使用另一个对象去实现，那就是xDomainRequest，而不是兼容XMLHttpRequest，写法看下面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var oXDomainRequest=new XDmainRequest();</div><div class="line">oXDomainRequest.onload=<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">   alert(this.responseText);</div><div class="line">&#125;</div><div class="line">oXDomainRequest.open(<span class="string">'get'</span>,<span class="string">'url'</span>,<span class="literal">true</span>);</div><div class="line">oXDomainRequest.send();</div></pre></td></tr></table></figure></p><p>封装了一个ajax<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> ajax(method, url, data, success) &#123;</div><div class="line">var xhr = null;</div><div class="line">try &#123;</div><div class="line">xhr = new XMLHttpRequest();</div><div class="line">&#125; catch (e) &#123;</div><div class="line">xhr = new ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (method == <span class="string">'get'</span> &amp;&amp; data) &#123;</div><div class="line">url += <span class="string">'?'</span> + data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">xhr.open(method,url,<span class="literal">true</span>);</div><div class="line"><span class="keyword">if</span> (method == <span class="string">'get'</span>) &#123;</div><div class="line">xhr.send();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">xhr.setRequestHeader(<span class="string">'content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line">xhr.send(data);</div><div class="line">&#125;</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line"><span class="keyword">if</span> ( xhr.readyState == 4 ) &#123;</div><div class="line"><span class="keyword">if</span> ( xhr.status == 200 ) &#123;</div><div class="line">success &amp;&amp; success(xhr.responseText);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">alert(<span class="string">'出错了,Err：'</span> + xhr.status);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做Web的需求一定会涉及到浏览器和服务器的交互，也就是B/S，B/S的交互又是通过HTTP协议，而post和get是HTTP协议中的两种方法。&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=497047516&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="post" scheme="http://yoursite.com/tags/post/"/>
    
      <category term="get" scheme="http://yoursite.com/tags/get/"/>
    
      <category term="eval" scheme="http://yoursite.com/tags/eval/"/>
    
      <category term="JSON.parse()" scheme="http://yoursite.com/tags/JSON-parse/"/>
    
      <category term="B/S的交互" scheme="http://yoursite.com/tags/B-S%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    
      <category term="HTTP协议" scheme="http://yoursite.com/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>cookies,sessionStorage和localStorage的区别</title>
    <link href="http://yoursite.com/2018/01/07/cookies-sessionStorage%E5%92%8ClocalStorage%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/01/07/cookies-sessionStorage和localStorage的区别/</id>
    <published>2018-01-07T09:50:15.000Z</published>
    <updated>2018-02-21T06:23:01.643Z</updated>
    
    <content type="html"><![CDATA[<p>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的。。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=165372&auto=0&height=66"></iframe><br><a id="more"></a><br>可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</p><h3 id="认识一下"><a href="#认识一下" class="headerlink" title="认识一下"></a>认识一下</h3><p>sessionStorage、 localStorage 、 cookie都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的 。</p><h3 id="各浏览器允许的cookie"><a href="#各浏览器允许的cookie" class="headerlink" title="各浏览器允许的cookie"></a>各浏览器允许的cookie</h3><p>IE8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。</p><p>Firefox每个域名cookie限制为50个</p><p>Opera每个域名cookie限制为 30 个 </p><p>Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。</p><h3 id="不同浏览器间cookie总大小也不同："><a href="#不同浏览器间cookie总大小也不同：" class="headerlink" title="不同浏览器间cookie总大小也不同："></a>不同浏览器间cookie总大小也不同：</h3><p>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。</p><p>Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。</p><p>Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。</p><p><span style="color:red">注：</span>多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。</p><h3 id="sessionStorage、localStorage和cookie的区别"><a href="#sessionStorage、localStorage和cookie的区别" class="headerlink" title="sessionStorage、localStorage和cookie的区别"></a>sessionStorage、localStorage和cookie的区别</h3><p>Cookie<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">每个域名存储量比较小（各浏览器不同，大致 4K ） </div><div class="line"></div><div class="line">所有域名的存储量有限制（各浏览器不同，大致 4K ） </div><div class="line"></div><div class="line">有个数限制（各浏览器不同） </div><div class="line"></div><div class="line">会随请求发送到服务器</div></pre></td></tr></table></figure></p><p>LocalStorage<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">永久存储 </div><div class="line"></div><div class="line">单个域名存储量比较大（推荐 5MB ，各浏览器不同） </div><div class="line"></div><div class="line">总体数量无限制</div></pre></td></tr></table></figure></p><p>SessionStorage<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">只在 Session 内有效 </div><div class="line"></div><div class="line">存储量更大（推荐没有限制，但是实际上各浏览器也不同）</div></pre></td></tr></table></figure></p><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cookie:浏览器端存储数据，内存比较小，并且有条数限制，会被发往服务器端，用于验证用户身份等操作，被http协议携带；</div><div class="line"></div><div class="line">sessionStorage:浏览器端存储数据，内存比较大，只存储在本地不发送到服务端，当本浏览器窗口被关闭，就会被删除；</div><div class="line"></div><div class="line">LocalStorage:浏览器端存储数据，内存比较大，只存储在本地不发送到服务端，当本浏览器窗口被关闭，不会被删除。</div></pre></td></tr></table></figure><h3 id="头脑风暴的深度剖析"><a href="#头脑风暴的深度剖析" class="headerlink" title="头脑风暴的深度剖析"></a>头脑风暴的深度剖析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cookies：一小段文本信息，伴随着用户请求和页面在服务器和浏览器之间传递。</div><div class="line">因HTTP协议是无状态的，对于一个浏览器发出的多次请求，web服务器无法区分是否来自同一个浏览器，</div><div class="line">此时需要额外的数据用于维持会话</div><div class="line"></div><div class="line">sessionStorage：用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问，</div><div class="line">会话结束数据随之销毁，它并非持久化的本地存储。 </div><div class="line"></div><div class="line">localStorage：用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期</div></pre></td></tr></table></figure><h3 id="cookies与web-storage-session-localStorage-区别："><a href="#cookies与web-storage-session-localStorage-区别：" class="headerlink" title="cookies与web storage(session|localStorage)区别："></a>cookies与web storage(session|localStorage)区别：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1、cookies大小受限，并且每次请求新页面时cookie都会被发送过去，无形中浪费了带宽；</div><div class="line">需要前端自己封装setCookie，getCookie；</div><div class="line">作用是与服务器进行交互。</div><div class="line"></div><div class="line">2、web storage具备更大容量存储，拥有setItem，getItem，removeItem，Clear等方法；</div><div class="line">作用是本地存储，避免数据在浏览器和服务器间不必要地来回传递</div></pre></td></tr></table></figure><h3 id="存储方式、存储大小，有效时间"><a href="#存储方式、存储大小，有效时间" class="headerlink" title="存储方式、存储大小，有效时间"></a>存储方式、存储大小，有效时间</h3><p>cookie是网站为了标示用户身份而储存在用户本地Client Side上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），会在浏览器和服务器间来回传递。 </p><p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 </p><p>存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p><p>有效时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p><p>sessionStorage 数据在当前浏览器窗口关闭后自动删除。<br>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p><h3 id="当很多的cookie被设置，浏览器如何去响应。"><a href="#当很多的cookie被设置，浏览器如何去响应。" class="headerlink" title="当很多的cookie被设置，浏览器如何去响应。"></a>当很多的cookie被设置，浏览器如何去响应。</h3><p>除了Safari（可以设置全部cookie，不管数量多少），有两个方法：Least Recently Used方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。</p><p>Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。</p><h3 id="设置cookie过期时间存储特殊字符的时候出问题"><a href="#设置cookie过期时间存储特殊字符的时候出问题" class="headerlink" title="设置cookie过期时间存储特殊字符的时候出问题"></a>设置cookie过期时间存储特殊字符的时候出问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//设置过期时间document.cookie=<span class="string">"hhardyy=zhen;expires=时间"</span>;</div><div class="line">//</div><div class="line">//chrome不允许操作本地cookie</div><div class="line">//firefox查看</div><div class="line"></div><div class="line">var oDate=new Date();</div><div class="line"></div><div class="line">oDate.toGMTString();//由于oDate是object，IE弹不出，所以要toGMTString()转换</div><div class="line">oDate.setDate(oDate.getDate()+5);//五天以后过期</div><div class="line"></div><div class="line">//内容编码存放，encodeURI</div><div class="line">//编码</div><div class="line">console.log(encodeURI(<span class="string">"你好"</span>));//弹出%E4%BD%A0%E5%A5%BD</div><div class="line">//解码</div><div class="line">console.log(decodeURI(<span class="string">"%E4%BD%A0%E5%A5%BD"</span>))//你好</div><div class="line"></div><div class="line">document.cookie=<span class="string">"hhardyy="</span>+encodeURI(<span class="string">'zhen\n黄炳圳'</span>)+<span class="string">";expires="</span>+oDate;</div><div class="line">document.cookie=<span class="string">"age=18"</span>;</div><div class="line">//浏览器关掉再打开之后，age没了，由于oDate是object，IE弹不出，所以要toGMTString()转换</div><div class="line"></div><div class="line">document.cookie=<span class="string">"age=18"</span>;</div><div class="line">//alert(document.cookie);</div><div class="line">//解码读取</div><div class="line">alert(decodeURI(document.cookie));</div></pre></td></tr></table></figure><h3 id="封装操作cookie的方法"><a href="#封装操作cookie的方法" class="headerlink" title="封装操作cookie的方法"></a>封装操作cookie的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">document.cookie=<span class="string">"hhardyy=zhen"</span>;</div><div class="line">document.cookie=<span class="string">"age=18"</span>;</div><div class="line">//创建cookie</div><div class="line"><span class="keyword">function</span> setCookie(key,value,t)&#123;</div><div class="line">    var oDate=new Date();</div><div class="line">    oDate.setDate(oDate.getDate()+t);</div><div class="line">    document.cookie=key+<span class="string">'='</span>+value+<span class="string">';expires='</span>+oDate.toGMTString();</div><div class="line">&#125;</div><div class="line">//删除cookie</div><div class="line"><span class="keyword">function</span> removeCookie(key)&#123;</div><div class="line">    setCookie(key,<span class="string">''</span>,-1);</div><div class="line">&#125;</div><div class="line">//获取cookie</div><div class="line"><span class="keyword">function</span> getCookie(key)&#123;</div><div class="line">    var arr1=document.cookie.split(<span class="string">'; '</span>);</div><div class="line">    <span class="keyword">for</span>(var i=0;i&lt;arr1.length;i++)&#123;</div><div class="line">    var arr2=arr1[i].split(<span class="string">'='</span>);</div><div class="line">&#125;</div><div class="line">    <span class="keyword">if</span> (arr2[0]==key) &#123;</div><div class="line">        <span class="built_in">return</span> decodeURI(arr2[1]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">setCookie(<span class="string">'sex'</span>,<span class="string">'男'</span>,10);</div><div class="line">console.log(getCookie(<span class="string">'hhardyy'</span>));</div><div class="line">removeCookie(<span class="string">'hhardyy'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的。。&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=165372&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="数据存储" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="cookies" scheme="http://yoursite.com/tags/cookies/"/>
    
      <category term="sessionStorage" scheme="http://yoursite.com/tags/sessionStorage/"/>
    
      <category term="localStorage" scheme="http://yoursite.com/tags/localStorage/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>中关村的圣诞</title>
    <link href="http://yoursite.com/2017/12/29/%E4%B8%AD%E5%85%B3%E6%9D%91%E7%9A%84%E5%9C%A3%E8%AF%9E/"/>
    <id>http://yoursite.com/2017/12/29/中关村的圣诞/</id>
    <published>2017-12-29T06:42:22.000Z</published>
    <updated>2017-12-29T07:22:15.897Z</updated>
    
    <content type="html"><![CDATA[<p>在中关村实训了一周，额，应该说老司机带飞了，碰巧在这过圣诞然后到元旦收队了~<a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=35955153&auto=0&height=66"></iframe><br>真正体验到什么是老前辈开发的高速飙车。</p><p>尴尬的是，我演示项目的时候突然bug，突然制杖，于是开始调试，于是排bug，于是再调试，讲师就开始问对于脑图那些东西辅助项目有什么想法等问题，然后我就答，然后突然他就说我合格了，突然就点评说我的性格沉稳不慌适合研究新技术，最后他说如果让他从我们中招四个人，然后我就被选了，然后我的圣诞就是跑了几年来的第一个三层架构java项目—虽然项目弱爆了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/zhongImg/zhong1.png" alt="“这里的路灯”" title="">                </div>                <div class="image-caption">“这里的路灯”</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/zhongImg/zhong2.jpg" alt="“这里的欧洲小镇”" title="">                </div>                <div class="image-caption">“这里的欧洲小镇”</div>            </figure>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在中关村实训了一周，额，应该说老司机带飞了，碰巧在这过圣诞然后到元旦收队了~
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="实训" scheme="http://yoursite.com/tags/%E5%AE%9E%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>node pash命令合集</title>
    <link href="http://yoursite.com/2017/12/20/node-pash%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2017/12/20/node-pash命令合集/</id>
    <published>2017-12-20T02:46:21.000Z</published>
    <updated>2017-12-20T03:47:44.547Z</updated>
    
    <content type="html"><![CDATA[<p>来一波node的命令大全，避免在敲命令的时候耍酷失败~</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=493283235&auto=0&height=66"></iframe><br><a id="more"></a><br>最近遇到个脑疼的问题，在升级node最新版本的时候，遇到了win不支持N模块的问题.<br>node 升级版本的命令：</p><h3 id="查看当前版本"><a href="#查看当前版本" class="headerlink" title="查看当前版本"></a>查看当前版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node -v</div></pre></td></tr></table></figure><h3 id="清除npm-cache"><a href="#清除npm-cache" class="headerlink" title="清除npm cache"></a>清除npm cache</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm cache clean -f</div></pre></td></tr></table></figure><h3 id="安装n模块"><a href="#安装n模块" class="headerlink" title="安装n模块"></a>安装n模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g n</div></pre></td></tr></table></figure><h3 id="升级到想要的版本，比如我自己现在的版本8-9"><a href="#升级到想要的版本，比如我自己现在的版本8-9" class="headerlink" title="升级到想要的版本，比如我自己现在的版本8.9"></a>升级到想要的版本，比如我自己现在的版本8.9</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo n 8.9.3</div></pre></td></tr></table></figure><h3 id="升级到最新的版本"><a href="#升级到最新的版本" class="headerlink" title="升级到最新的版本"></a>升级到最新的版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo n stable</div></pre></td></tr></table></figure><p>再次node -v查看当前版本，必要的时候可以重启一下看看。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/nodeImg/up1.JPG" alt="“我之前是6.9.5版本，这是升级之后的版本，没记得截图6.9.5~~”" title="">                </div>                <div class="image-caption">“我之前是6.9.5版本，这是升级之后的版本，没记得截图6.9.5~~”</div>            </figure>;</p><p>注意：win系统不支持n模块的话直接用命令升级是不靠谱的，我开始也在和它死磕，一直不靠谱之后听了朋友建议直接去官网下=  。=</p><h3 id="常用node-npm命令"><a href="#常用node-npm命令" class="headerlink" title="常用node npm命令"></a>常用node npm命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">npm install moduleNames：安装Node模块 </div><div class="line"></div><div class="line">npm start 启动模块</div><div class="line"></div><div class="line">npm stop 停止模块</div><div class="line"></div><div class="line">npm restart 重新启动模块</div><div class="line"></div><div class="line">npm cache 管理模块的缓存</div><div class="line"></div><div class="line">npm config管理npm的配置路径</div><div class="line"></div><div class="line">npm view moduleNames：查看node模块的package.json文件夹</div><div class="line"></div><div class="line">npm list：查看当前目录下已安装的node包</div><div class="line"></div><div class="line">npm <span class="built_in">help</span>：查看帮助命令</div><div class="line"></div><div class="line">npm view moudleName dependencies：查看包的依赖关系 </div><div class="line"></div><div class="line">npm view moduleName repository.url：查看包的源文件地址 </div><div class="line"></div><div class="line">npm view moduleName engines：查看包所依赖的Node的版本 </div><div class="line"></div><div class="line">npm <span class="built_in">help</span> folders：查看npm使用的所有文件夹 </div><div class="line"></div><div class="line">npm rebuild moduleName：用于更改包内容后进行重建  </div><div class="line"></div><div class="line">npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新  </div><div class="line"></div><div class="line">npm update moduleName：更新node模块 </div><div class="line"></div><div class="line">npm uninstall moudleName：卸载node模块 </div><div class="line"></div><div class="line">一个npm包是包含了package.json的文件夹，package.json描述了这个文件夹的结构。访问npm的json文件夹的方法如下： $ npm <span class="built_in">help</span> json   此命令会以默认的方式打开一个网页，如果更改了默认打开程序则可能不会以网页的形式打开。</div><div class="line"></div><div class="line">发布一个npm包的时候，需要检验某个包名是否已存在 $ npm search packageName  </div><div class="line"></div><div class="line">npm init：会引导你创建一个package.json文件，包括名称、版本、作者这些信息等 </div><div class="line"></div><div class="line">npm root：查看当前包的安装路径 npm root -g：查看全局的包的安装路径</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来一波node的命令大全，避免在敲命令的时候耍酷失败~&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=493283235&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="node命令" scheme="http://yoursite.com/tags/node%E5%91%BD%E4%BB%A4/"/>
    
      <category term="pash" scheme="http://yoursite.com/tags/pash/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>node的一个小问题</title>
    <link href="http://yoursite.com/2017/12/01/node%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/12/01/node的一个小问题/</id>
    <published>2017-12-01T15:47:52.000Z</published>
    <updated>2017-12-01T16:17:43.561Z</updated>
    
    <content type="html"><![CDATA[<p>来个node的小bug<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5273093&auto=0&height=66"></iframe><br><a id="more"></a><br>当你用360或者什么七七八八的清理工具清理电脑的时候，再跑node可能会遇到这样的问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/nodeImg/nodebug1.JPG" alt="“......”" title="">                </div>                <div class="image-caption">“......”</div>            </figure><p>原因可能是它的配置文件或者组成文件环境什么的被你亲手干掉了。</p><p>这个时候有两种解决方案（我知道的）<br>1、重装系统（简单粗暴）<br>2、重置node<br>重装系统自己百度</p><p>重置node的话，有个命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netsh winsock reset</div></pre></td></tr></table></figure></p><p>这个命令需要最高管理员权限，普通的cmd在它面前太弱跑不了。</p><p>跑完这条命令之后，重启一下电脑，然后win+R然后cmd然后node -v。</p><p>最后看天意，靠谱的话就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来个node的小bug&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=5273093&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="node bug" scheme="http://yoursite.com/tags/node-bug/"/>
    
  </entry>
  
</feed>
